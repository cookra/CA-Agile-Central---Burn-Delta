<!DOCTYPE html>
<html>
<head>
    <title>Burndown</title>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.DateMixin", {

        dateFormatters: [
            {key: "MMM", value: "%b"},
            {key: "MM", value: "%m"},
            {key: "dd", value: "%d"},
            {key: "yyyy", value: "%Y"}
        ],

        dateToStringDisplay: function (date) {
            return Ext.Date.format(date, 'm/d/Y');
        },

        dateToString: function (date) {
            return Ext.Date.format(date, 'Y-m-d\\TH:i:s.u\\Z');
        },

        dateStringToObject: function (dateStr) {
            var finalIndex = dateStr.indexOf('T'),
                dateObj;

            if (finalIndex > -1) {
                dateStr = dateStr.slice(0, dateStr.indexOf('T'));
            }

            dateObj = this._splitDateParts(dateStr);

            return new Date(dateObj.year, dateObj.month, dateObj.day);
        },

        _getMonth: function(month) {
            var monthMap = { jan: 0, feb: 1, mar: 2, apr: 3,
                             may: 4, jun: 5, jul: 6, aug: 7,
                             sep: 8, oct: 9, nov: 10, dec: 11 };
            if(isNaN(month)) {
                try {
                    month = monthMap[month.toLowerCase()];
                } catch(err) { }
            } else {
                month = parseInt(month, 10) - 1;
            }

            return month.toString();
        },

        _objectFromYearFirstDate: function (dateArray) {
            var month = 0,
                day = 0,
                year = 0;

            if (dateArray.length !== 3) {
                return { year: year, month: month, day: day };
            }

            year = dateArray[0];
            month = this._getMonth(dateArray[1]);
            day = dateArray[2];

            return {
                year: year,
                month: month,
                day: day
            };
        },

        _objectFromMonthFirstDate: function (dateArray) {
            var month = 0,
                day = 0,
                year = 0;

            if (dateArray.length !== 3) {
                return { year: year, month: month, day: day };
            }

            month = this._getMonth(dateArray[0]);
            day = dateArray[1];
            year = dateArray[2];

            return {
                month: month,
                day: day,
                year: year
            };
        },

        _shouldSplitOnDash: function (dateStr) {
            return dateStr.split('-').length === 3;
        },

        _splitDateParts: function (dateStr) {
            if (this._shouldSplitOnDash(dateStr)) {
                return this._objectFromYearFirstDate(dateStr.split('-'));
            }
            else {
                return this._objectFromMonthFirstDate(dateStr.split('/'));
            }
        }

    });

}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.IntegrationHeaders", {

        keyConverters : {
            name : function() { return 'X-RallyIntegrationName'; },
            vendor : function() { return 'X-RallyIntegrationVendor'; },
            platform : function() { return 'X-RallyIntegrationPlatform'; },
            os : function() { return 'X-RallyIntegrationOS'; },
            version : function() { return 'X-RallyIntegrationVersion'; },
            library : function() { return 'X-RallyIntegrationLibrary'; }
        },

        constructor: function(config) {
            this.headers = {
                name : 'A2 Chart',
                vendor : 'Rally Software'
            };

            Ext.merge(this.headers, config.integrationHeaders || {});
            this.callParent(config);
        },
        withName : function(nm) {
            this.headers.name = nm || this.headers.name;
            return this;
        },
        withVendor : function(v) {
            this.headers.vendor = v || this.headers.vendor;
            return this;
        },
        withPlatform : function(newPlatform) {
            this.headers.platform = newPlatform || this.headers.platform;
            return this;
        },
        withVersion : function(newVersion) {
            this.headers.version = newVersion || this.headers.version;
            return this;
        },
        withOS : function(newOS) {
            this.headers.os = newOS || this.headers.os;
            return this;
        },
        withLibrary : function(newLibrary) {
            this.headers.library = newLibrary || this.headers.library;
            return this;
        },
        applyTo : function(config) {
            config.headers = config.headers || {};
            Ext.merge(config.headers, this.build());
            return config;
        },
        build : function() {
            var h = {};
            for (var k in this.headers) {
                if (this.headers.hasOwnProperty(k)) {
                    if (this.headers[k] === null) { continue; }
                    var key = this._keyConverter(k)(k);
                    h[key] = this.headers[k];
                }
            }
            return h;
        },
        _keyConverter: function(key) {
            if (this.keyConverters.hasOwnProperty(key)) {
                return this.keyConverters[key];
            } else {
                return function(x) {return x;};
            }
        }
    });
}());

                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.RadioGroupSetting", {
        extend: "Ext.form.FieldContainer",

        config: {
            settingName: undefined
        },

        constructor: function(config) {
            this.mergeConfig(config);
            this.callParent(arguments);
        },

        getSetting: function() {
            return this.settingsParent.app.getSetting(this.settingName);
        },

        setRadioValue: function (cmp) {
            this.setRadioToCustomValue(cmp, this.getSetting());
        },

        setRadioToCustomValue: function (cmp, customValue) {
            var value = {};
            value[cmp.name] = customValue;
            cmp.setValue(value);
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.ChartDisplayTypePicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.chartdisplaytypepicker",

        mixins: [
            "Ext.form.field.Field"
        ],

        config: {
            settingName: "chartDisplayType"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this.add(this._getPicker());
        },

        _getPicker: function () {
            return {
                xtype: "radiogroup",
                name: this.settingName,
                columns: [160, 100],
                vertical: false,
                items: [
                    { boxLabel: "Area", name: this.settingName, inputValue: "area"},
                    { boxLabel: "Column", name: this.settingName, inputValue: "column" },
                    { boxLabel: "Line", name: this.settingName, inputValue: "line" },
                    { boxLabel: "Spline", name: this.settingName, inputValue: "spline", checked: true  },
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                }
            };
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.SettingsChangeMixin", {

        sendSettingsChange: function(artifact) {
            if (this.settingsParent) {
                this.settingsParent.sendSettingsChange(artifact, this);
            }
        },

        receiveSettingsChange: function(artifact) {

        }

    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.DataTypePicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.chartdatatypepicker",

        mixins: [
            "Ext.form.field.Field",
            "Rally.apps.charts.settings.SettingsChangeMixin"
        ],

        config: {
            settingName: "chartAggregationType"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this.add(this._addRadioGroup());
        },

        _addRadioGroup: function () {
            return {
                xtype: "radiogroup",
                name: this.settingName,
                columns: [160, 100],
                vertical: false,
                items: [
                    { boxLabel: "Story Plan Estimate", name: this.settingName, inputValue: "storypoints", checked: true },
                    { boxLabel: "Story Count", name: this.settingName, inputValue: "storycount" }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                }
            };
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.TimeboxPicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.charttimeboxpicker",

        mixins: [
            "Ext.form.field.Field"
        ],

        config: {
            settingName: "chartTimebox"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this._addRadioGroup();
        },

        _addRadioGroup: function () {
            this.add({
                xtype: "radiogroup",
                name: this.settingName,
                itemId: this.settingName,
                label: "Level",
                columns: [160, 100, 100],
                vertical: false,
                items: [
                    //{ boxLabel: "Release", name: this.settingName, inputValue: "release", checked: true },
                    { boxLabel: "Iteration", name: this.settingName, inputValue: "iteration", checked: true }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                },
                config: {
                    cls: "levelchooser"
                }
            });
        }
    });
}());

                Ext.define('App.Config', {
    config: {
        // Quick Test //
        PpanelsCollapsed: false,
        // Versioning //
        Pversion: 'v1.9b',
        PappID: 'AC Burn Delta',
        Powner: 'Richard Cook',
        PreleaseDate: '2017-03-16: 11:47 GMT',
        Pdescription: 'AC Burn Delta, click on the applications gear to see "App Settings".',


        Pusage: 'AC Burn Delta: Deployment</br>' +
            '[1]: As is [ Custom Page - Set to filter by Iteration, with a Custom HTML application ] (Select setting from the config and copy the source code)</br>' +
            '[2]: As a standalone app within a Dashboard',
        Psupport: '</br></br>AC Burn Delta: Support<br>' +
            'The Support button below will collect & email the following details via your default email client (you will be able to view this informatio before sending):</br>' +
            '[1]: System information (various information about the system you are using)</br>' +
            '[2]: Agile Central information (various information on the workspace, project and user account setting)',

        // Git Repo Details
        PrepoAddress: 'not shared',
        // Emailer Contact Details
        pEmailSupportMessage: '*** [AC AC Burn Delta] Custom Application AC Support Request',
        pEmailSupportAddress: 'richard.cook@barclaycard.co.uk',
        pEmailerMessage: '========== Please add your comments above this line ==========',
        // Rally Colours
        PrallyColours_10: ['#0096DB', '#004A9D', '#FF3C00', '#FF8D00', '#FFDC00', '#6F7376', '#FFF', '#FF0069', '#41006E', '#00710C'],
        // Barclays Colours
        PbarclaysColours_5: ['#145FAC', '#437EA0', '#00AEEF', '#FFF', '#FFA000'],

        PmyColours: ["#d61551", "#c9506f", "#6a0b70", "#0e1026", "#e53118", "#262428", "#c9d940", "#d3272b", "#ea2b30", "#59595b", "#242021", "#ebe7e4", "#437EA0"], // Bits we need
        PtabBGstripePercent: 5,


    },
    _divPanels: function (a, b) {
        var o;
        var st = 'style="';
        var bg = 'background:';
        var md = ';';
        var cl = 'color:';
        var f = '";';
        var megan = [{
            "header": "#d61551"
        }, {
            "color": "#c9506f"
        }];
        o = st + bg + megan[a].header+ md + cl + megan[b].color + f;


        return o;
    },
    _writePanelContent: function (t) {

        if (t === 'about') {
            var o = '<div class="divTable">' +
                '<div class="divTableBody">' +
                '<div class="divTableRowHeader">' +
                '<div class="divTableCellHeader_stretched" ' + this._divPanels(0,1) + '>About</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellHeader" ' + this._divPanels(0,1) + '>Configuration</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellHeader" ' + this._divPanels(0,1) + '">Data Types</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellHeader" ' + this._divPanels(0,1) + '>Chart Type</div>' +
                '</div>' +
                '<div class="divTableRowContent">' +
                '<div class="divTableCellContent_stretched contentBg1">Displays the Burn delta between remaining and accepted user stories</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellContent contentBg2">&nbsp;</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellContent contentBg2"><ol><li>Planned Estimate</li><li>User Story Count</li></ol></div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellContent contentBg2"><ol><li>Area</li><li>Column</li><li>Line</li><li>Split</li></ol></div>' +
                '</div>' +
                '</div>' +
                '</div>';
            return o;
        }
    },
    _generate_Version: function () {
        var output = this.Pversion;
        return output;
    },
    constructor: function (config) {
        this.initConfig(config);
    },
});
                Ext.define('App.Emailer', {
    _emailer: function (context_User, context_Project, context_Workspace) {
        var string, subject;
        subject = Ext.create('App.Config').pEmailSupportMessage;
        string = '\r\n';
        string += '\r\n';
        string += '\r\n';
        string += Ext.create('App.Config').pEmailerMessage;
        string += '\r\n';
        string += Ext.create('App.System')._this_Application_Details('email');
        string += Ext.create('App.System')._user_Vars();
        string += Ext.create('App.System')._user_Rally_Vars(context_User, context_Project, context_Workspace);
        console.log(string);
        string = encodeURIComponent(string);
        window.location = 'mailto:' + Ext.create('App.Config').pEmailSupportAddress + '?subject=' + subject + '&body=' + string;
    },
});
                Ext.define('App.Layout', {
    _create: function (o) {
        if (o.type === 'btn') {
            console.log(o);
            var object = Ext.create('Ext.button.Button', {
                text: o.text,
                margin: o.margin,
                cls: o.cls,
                style: {
                    backgroundColor: o.color,
                },
                listeners: {
                    afterrender: function (v) {
                        v.el.on('click', function () {
                            console.log('[' + o.type + '] Clicked');
                            Ext.create('App.Emailer')._emailer(MySharedData.supportArray, a_context_User, a_context_Project, a_context_Workspace);
                        });
                    },
                    scope: this
                },
            });
            return object;
        } else if (o.type === 'con') {
            console.log('CONTAINER ',o);
            var object = Ext.create('Ext.container.Container', {
                layout: o.layout,
                align: o.align,
                height: o.height,
                width: o.height,
                border: o.border,
                id: o.id,
                itemId: o.itemId,
                margin: o.margin,
                padding: o.padding,
                html: o.html,
                cls: o.cls,
                style: {
                    background: o.bg_color,
                },
                layoutConfig: {
                    align: o.align,
                },
            });
            return object;
        } else if (o.type === 'pan') {
            console.log(o);
            var object = Ext.create('Ext.panel.Panel', {
                layout: o.layout,
                align: o.align,
                height: o.height,
                width: o.width,
                border: o.border,
                id: o.id,
                itemId: o.itemId,
                margin: o.margin,
                padding: o.padding,
                html: o.html,
                bodyPadding: o.bodyPadding,
                cls: o.cls,
                flex: o.flex,
                style: {
                    background: o.color,
                },
            });
            return object;
        } else if (o.type === 'udd') {
            console.log(o);
            var object = Ext.create('Rally.ui.combobox.UserSearchComboBox', {
                storeConfig: {
                    model: o.model
                },
                fieldLabel: o.fieldLabel,
                project: o.project,
                itemId: o.itemId,
                id: o.id,
                margin: o.margin,
                noEntryText: '-- All --',
                defaultSelectionPosition: 'first',
                listeners: {
                    select: function () {
                        console.log('clicked');
                        this._mask('myInfoPanel');
                        this._kickoff('User');
                    },
                    scope: this
                }
            });
            return object;
        } else if (o.type === 'idd') {
            console.log(o);
            var object = Ext.create('Rally.ui.combobox.PortfolioItemTypeComboBox', {

                itemId: o.itemId,
                fieldLabel: o.fieldLabel,
                labelAlign: o.labelAlign,
                id: o.id,
                margin: o.margin,
                listeners: {
                    select: function () {
                        console.log('clicked');
                        this._mask('myInfoPanel');
                        this._kickoff('User');
                    },
                    scope: this
                }
            });
            return object;
        } else if (o.type === 'ser') {
            console.log(o);
            var object = Ext.create('Rally.ui.combobox.SearchComboBox', {
                storeConfig: {
                    model: o.model
                },
                itemId: o.itemId,
                fieldLabel: o.fieldLabel,
                labelAlign: o.labelAlign,
                id: o.id,
                margin: o.margin,
                width: o.width,
                listeners: {
                    specialkey: function (field, e) {
                        if (e.getKey() === e.ENTER) {
                            console.log('enter');
                            this._mask('myInfoPanel');
                            this._kickoff('Search');
                        }
                    },
                    select: function () {
                        console.log('select');
                        this._mask('myInfoPanel');
                        this._kickoff('Search');
                    },
                    scope: this
                }
            });
            return object;
        }else if (o.type === 'box') {
            console.log(o);
            var object = Ext.create('Ext.Component', {
                height: o.height,
                width: o.width,
                id: o.id,
                margin: o.margin,
                autoEl: {
                    tag: 'div',
                    cls: 'myInfoPanel',
                    html: "",
                },
                flex:1,
            });
            return object;
        }
    }
});
                Ext.define('App.Loader', {
    _build: function (type) {
        var output;
        var colour_Array = Ext.create('App.Config').PrallyColours_10;
        var colour_Norm = colour_Array[Math.floor((Math.random() * 10))];
        var Colour_Dark = Ext.create('App.Tools')._shadeBlendConvert(colour_Norm, -30);
        switch (type) {
            case 'bar':
                var html = 'style= "background-image: repeating-linear-gradient(-45deg,' + colour_Norm + ',' + colour_Norm + ' 11px,' + Colour_Dark + ' 10px,' + Colour_Dark + ' 20px")';
                output = '<div class = "bar" ' + html + '></div>';
                break;
            case 'wave':
                output = '<div class = "loader">Loading...</div>';
                break;
        }
        return output;
    }
});
                Ext.define('App.System', {
    // Created by Richard Cook ::: Cookra Limited
    // Barclaycard richard.cook@barclaycard.co.uk
    // v4.8
    // Updated 2017-03-08
    _this_Application_Details: function (type) {
        var Output;
        var a = [];
        a.push('> - - - - - - - - - - < Application Details');
        a.push('> App Name : ' + 'Orphaned Items');
        a.push('> App Version : ' + 'v4.1b');
        a.push('> App Version Status : ' + 'beta');
        a.push('> App Designer : ' + 'Richard Cook');
        a.push('> App Description : ' + 'Custom Ext JS Application that displays orphaned artifacts');
        a.push('> App Release Date : ' + '2017-03-13');
        if(type==='email'){
            output = Ext.create('App.Tools')._common_Array_Outputter(a);
        }else if(type==='inapp'){
            output = a;
        }
        return output;
    },
    _this_Application_Output: function (array) {
        var a = [];
        console.log('xxx ',array);
        a.push('> - - - - - - - - - - < Application Output');
        for (var i = 0; i < array.length; i++) {
            a.push('> FormattedID : ' + array[i].raw.FormattedID + ' Name : ' + array[i].raw.Name + ' _Ref : ' + array[i].raw._ref);
        }
        array = undefined;
        return Ext.create('App.Tools')._common_Array_Outputter(a);
    },
    _user_Vars: function () {
        var a = [];
        a.push('> - - - - - - - - - - < Local Details');
        a.push('> Browser Web App Name : ' + navigator.appName);
        a.push('> Browser User Agent : ' + navigator.userAgent);
        a.push('> Browser Version : ' + navigator.appVersion);
        a.push('> Browser Code Name : ' + navigator.appCodeName);
        a.push('> Platform : ' + navigator.platform);
        a.push('> OS CPU : ' + navigator.oscpu);
        a.push('> Cookies : ' + navigator.cookieEnabled);
        a.push('> Outer Width : ' + window.outerWidth);
        a.push('> Outer Height : ' + window.outerHeight);
        a.push('> Inner Width : ' + window.innerWidth);
        a.push('> Inner Height : ' + window.innerHeight);
        a.push('> Base URI : ' + document.getElementsByTagName('script')[0].baseURI);
        a.push('> SRC : ' + document.getElementsByTagName('script')[0].src);
        a.push('> LocalName : ' + document.getElementsByTagName('script')[0].localName);
        a.push('> Type : ' + document.getElementsByTagName('script')[0].type);
        return Ext.create('App.Tools')._common_Array_Outputter(a);
    },
    _user_Rally_Vars: function (context_User, context_Project, context_Workspace) {
        var a = [];
        a.push('> - - - - - - - - - - < User Details');
        a.push('> AC User Username : ' + context_User.UserName);
        a.push('> AC User Name : ' + context_User._refObjectName);
        a.push('> AC User Role : ' + context_User.Role);
        a.push('> AC Application Launched From Node : ' + context_Project._refObjectName);
        a.push('> AC Application Workspace Name : ' + context_Workspace._refObjectName);
        a.push('> AC Application Workspace Date/Time Format : ' + context_Workspace.WorkspaceConfiguration.DateFormat);
        return Ext.create('App.Tools')._common_Array_Outputter(a);
    },
});
                Ext.define('Loading', {
    singleton: true,
    _mask: function (message) {
        console.log('@ _mask We are loading the store, show the spinner');
        if (this.sparkler) {
            this.sparkler.destroy();
        }
        this.sparkler = new Ext.LoadMask(this, {
            msg: message
        });
        this.sparkler.show();
    },
    _unmask: function () {
        console.log('@ _unmask We have the data so destroy the spinner');
        if (this.sparkler) {
            this.sparkler.hide();
        }
    },
});
                Ext.define('App.Tools', {
    _shadeBlendConvert: function (color, percent) {
        var R = parseInt(color.substring(1, 3), 16);
        var G = parseInt(color.substring(3, 5), 16);
        var B = parseInt(color.substring(5, 7), 16);
        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);
        R = (R < 255) ? R : 255;
        G = (G < 255) ? G : 255;
        B = (B < 255) ? B : 255;
        var RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
        var GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
        var BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));
        return "#" + RR + GG + BB;
    },
    _common_Array_Outputter: function (array) {
        var character_Return = '\r\n';
        var l = array.length;
        var output = '';
        var padSize = String(l).length;
        for (var x = 0; x < l; x++) {
            output += '[#' + this._number_Pad(x, padSize) + '] ' + array[x] + character_Return;
        }        
        console.log(output);
        array = undefined;
        return output;
    },
    _number_Pad: function (num, size) {
        return Array(Math.max(size - String(num).length + 1, 0)).join(0) + num;
    }
});
                Ext.define('App.Information', {
    config: {
        // Rally Colours
        //PrallyColours_10: ['#0096DB', '#004A9D', '#FF3C00', '#FF8D00', '#FFDC00', '#6F7376', '#FFF', '#FF0069', '#41006E', '#00710C'],
        // Barclays Colours
        //PbarclaysColours_5: ['#145FAC', '#437EA0', '#00AEEF', '#FFF', '#FFA000'],

        //PmyColours: ["#d61551", "#c9506f", "#6a0b70", "#0e1026", "#e53118", "#262428", "#c9d940", "#d3272b", "#ea2b30", "#59595b", "#242021", "#ebe7e4", "#437EA0"], // Bits we need
        PtabBGstripePercent: 5,
    },
    _divFormater: function (a, b) {
        var o;
        var st = 'style="';
        var bg = 'background:';
        var md = ';';
        var cl = 'color:';
        var f = '";';
        var megan = [{
            "header": "#d61551"
        }, {
            "color": "#c9506f"
        }];
        o = st + bg + megan[a].header + md + cl + megan[b].color + f;


        return o;
    },
    _writePanelContent: function (t) {
        if (t === 'about') {
            var o = '<div class="divTable">' +
                '<div class="divTableBody">' +
                '<div class="divTableRowHeader">' +
                '<div class="divTableCellHeader_stretched" ' + this._divFormater(0, 1) + '>About</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellHeader" ' + this._divFormater(0, 1) + '>Configuration</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellHeader" ' + this._divFormater(0, 1) + '">Data Types</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellHeader" ' + this._divFormater(0, 1) + '>Chart Type</div>' +
                '</div>' +
                '<div class="divTableRowContent">' +
                '<div class="divTableCellContent_stretched" ' + this._divFormater(1, 0) + '>Displays the Burn delta between remaining and accepted user stories</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellContent" ' + this._divFormater(1, 0) + '>&nbsp;</div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellContent" ' + this._divFormater(1, 0) + '><ol><li>Planned Estimate</li><li>User Story Count</li></ol></div>' +
                '<div class="divSpacer">&nbsp;</div>' +
                '<div class="divTableCellContent" ' + this._divFormater(1, 0) + '><ol><li>Area</li><li>Column</li><li>Line</li><li>Split</li></ol></div>' +
                '</div>' +
                '</div>' +
                '</div>';
            return o;
        }
    },
    _generate_Version: function () {
        var output = this.Pversion;
        return output;
    },
    _generate_Tabs: function () {
        var h_panel = 160;
        var h_button = 25;
        var p_panel = 10;
        var f_panel_font_size = 15;
        var colour_Shade_Percent = 20;

        var xData1;// = getContext().getUser();
        var xData2;// = getContext().getProject();
        var xData3;// = getContext().getWorkspace();
        var appVersion = Ext.create('App.System')._this_Application_Details('inapp');
        var myColours_Barclays = Ext.create('App.Config').PbarclaysColours_5;
        var myColours_MyColours = Ext.create('App.Config').PmyColours;

        var about___Text = this._writePanelContent('about');
        var version_Text = Ext.create('App.Config')._generate_Version();
        var usage___Text = Ext.create('App.Config').Pusage;
        var support___Text = Ext.create('App.Config').Psupport;

        /* Colour Reference from Config Arrays
        PmyColours: ["#d61551", "#c9506f", "#6a0b70", "#0e1026", "#e53118", "#262428", "#c9d940", "#d3272b", "#ea2b30", "#59595b", "#242021", "#ebe7e4", "#437EA0"],
        PbarclaysColours_5: ['#145FAC', '#437EA0', '#00AEEF', '#FFF', '#FFA000'],
        */
        /* ACTIVE THEME -> Orange */
        var tabColour_1 = myColours_MyColours[11];
        var tabColour_2 = myColours_MyColours[11];
        var tabColour_3 = myColours_MyColours[11];
        var panelBaseColor = myColours_MyColours[12];
        var bodyStyle = 'font-size:' + f_panel_font_size + 'px;padding:' + p_panel + 'px;';

        var colour_Background_Darken = Ext.create('App.Tools')._shadeBlendConvert(panelBaseColor, colour_Shade_Percent);
        var colour_Background = 'background: repeating-linear-gradient(  45deg,  ' + panelBaseColor + ',' + panelBaseColor + ' 10px,  ' + colour_Background_Darken + ' 10px,  ' + colour_Background_Darken + ' 20px);';
        // Build Details Container
        var container = Ext.create('Ext.container.Container', {
            xtype: 'Viewport',
            items: [{
                region: 'north',
                collapsed: Ext.create('App.Config').PpanelsCollapsed,
                items: [{
                    xtype: 'tabpanel',
                    width: '100%',
                    items: [{
                        title: 'About',
                        width: '100%',
                        html: about___Text,
                        height: h_panel,
                        bodyStyle: colour_Background + bodyStyle,
                        cls: 'fixTabMargins',
                        tabConfig: {
                            style: {
                                background: tabColour_1,
                            }
                        },
                        /*
                        buttons: [{
                            text: 'Button 1'
                        }]
                        */
                    }, {
                        title: 'Usage',
                        width: '100%',
                        html: usage___Text,
                        height: h_panel,
                        bodyStyle: colour_Background + bodyStyle,
                        cls: 'fixTabMargins',
                        tabConfig: {
                            style: {
                                background: tabColour_2,
                            }
                        },
                    }, {
                        title: 'Version',
                        width: '100%',
                        html: version_Text,
                        height: h_panel,
                        bodyStyle: colour_Background + bodyStyle,
                        cls: 'fixTabMargins',
                        tabConfig: {
                            style: {
                                background: tabColour_2,
                            }
                        },
                    }, {
                        title: 'Support',
                        width: '100%',
                        html: support___Text,
                        height: h_panel,
                        bodyStyle: colour_Background + bodyStyle,
                        cls: 'fixTabMargins',
                        tabConfig: {
                            style: {
                                background: tabColour_3,
                            }
                        },
                        items: [{
                            xtype: 'button',
                            text: 'Contact Support',
                            height: h_button,
                            style: {
                                backgroundColor: 'red',
                            },
                            listeners: {
                                afterrender: function (v) {
                                    v.el.on('click', function () {
                                        Ext.create('App.Emailer')._emailer(xData1, xData2, xData3);
                                    });
                                },
                                scope: this
                            },
                        }]
                    }]
                }]
            }]
        });
        return container;
    },
    constructor: function (config) {
        this.initConfig(config);
    },
});
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownSettings", {
        requires: [
            "Rally.apps.charts.settings.ChartDisplayTypePicker",
            "Rally.apps.charts.settings.DataTypePicker",
            "Rally.apps.charts.settings.TimeboxPicker",
            "Rally.ui.CheckboxField"
        ],

        config: {
            app: undefined
        },
        
        constructor: function (config) {
            this.mergeConfig(config);
        },

        _buildSettingsComponent: function (type, label, name) {
            console.log(type,label,name);
            var self = this;

            var componentAdded = function (cmp) {
                this.settingsParent = this.settingsParent || self;
            };

            var settings = {
                xtype: type,
                label: label,
                listeners: {
                    added: componentAdded
                }
            };
            if (name) {
                settings.name = name;
                settings.cls = "settings-" + name;
            }
            return settings;
        },

        _isOnScopedDashboard: function() {
            return this.app.isOnScopedDashboard() && !!this.app.context.getTimeboxScope();
        },

        getFields: function() {
            var dataTypePicker = this._buildSettingsComponent("chartdatatypepicker", "Data Type"),
                displayPicker = this._buildSettingsComponent("chartdisplaytypepicker", "Chart Type"),
                timeboxPicker = this._buildSettingsComponent("charttimeboxpicker", "Level"),
                labelNameVisible = this._buildSettingsComponent("rallycheckboxfield", "Show Iteration Labels", 'showLabels');
            
            if(this._isOnScopedDashboard()) {
                return [dataTypePicker, displayPicker, labelNameVisible];
            } else {
                return [timeboxPicker, dataTypePicker, displayPicker, labelNameVisible];
            }
        }
        

    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownChart", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        defaultChartComponentConfig: function () {
            return {
                xtype: "rallychart",
                itemId: "burndownchart",
                aggregationErrorMessage: "No data to display. Check the data type setting for displaying data based on count versus plan estimate.",

                storeType: "Rally.data.lookback.SnapshotStore",
                storeConfig: {
                    find: {
                        "_TypeHierarchy": {
                            '$in': [-51038, -51006]
                        },
                        "Children": null
                    },
                    fetch: ["ScheduleState", "PlanEstimate", "ObjectId", "_ValidFrom", "_ValidTo"],
                    hydrate: ["ScheduleState"],
                    sort: {
                        "_ValidFrom": 1
                    },
                    compress: true,
                    useHttpPost: true
                },

                calculatorType: "Rally.apps.charts.burndown.BurnDownCalculator",
                calculatorConfig: {
                    timeZone: "GMT",
                    completedScheduleStateNames: null, // defaults hide problems
                    enableProjections: true

                    //chartAggregationType: ''
                },
                chartColors: ["#7cc6f4", "#dee255", "#666666", "#c0c0c0"],
                cls: 'myCustom',
                overCls: 'myOver',

                chartConfig: {
                    chart: {
                        zoomType: "xy",
                        backgroundColor: '#ebe7e4',
                        type: 'area',
                        grid: true,
                    },
                    xAxis: {
                        categories: [],
                        tickmarkPlacement: "on",
                        tickInterval: 7,
                        title: {
                            text: "Days",
                            margin: 12
                        },
                        maxPadding: 0.25,
                        labels: {
                            x: 0,
                            y: 20,
                            overflow: "justify"
                        }
                    },

                    yAxis: [{
                        plotOptions: {
                            series: {
                                threshold: 0,
                            }
                        },
                    }],
                    tooltip: {
                        formatter: function () {
                            var floatValue = parseFloat(this.y),
                                value = this.y;

                            if (!isNaN(floatValue)) {
                                value = Math.floor(floatValue * 100) / 100;
                            }

                            return "" + this.x + "<br />" + this.series.name + ": " + value;
                        }
                    },
                    plotOptions: {
                        series: {
                            marker: {
                                enabled: true,
                                symbol: 'circle',
                                radius: 3,
                                states: {
                                    hover: {
                                        enabled: true
                                    }
                                }
                            },
                            area: {
                                stacking: 'normal'
                            },
                            connectNulls: true
                        },
                        column: {
                            pointPadding: 0,
                            borderWidth: 0,
                            stacking: null,
                            shadow: false
                        }
                    }
                }
            };

        }
    });
}());
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.charts.burndown.BurnDownApp', {
        extend: 'Rally.app.TimeboxScopedApp',

        settingsScope: 'workspace',

        requires: [
            'Rally.apps.charts.burndown.BurnDownSettings',
            'Rally.data.wsapi.Store',
            'Rally.util.Help',
            'Rally.ui.combobox.IterationComboBox',
            'Rally.ui.combobox.ReleaseComboBox',
            'Rally.apps.charts.IntegrationHeaders',
            'Rally.apps.charts.burndown.BurnDownChart'
        ],

        mixins: [
            'Rally.apps.charts.DateMixin'
        ],

        cls: 'burndown-app',

        items: [{
            xtype: 'container',
            itemId: 'header',
            cls: 'header'
        }],


        scopeObject: undefined,

        customScheduleStates: null, // defaults hide problems

        config: {
            defaultSettings: {
                showLabels: true,
                chartAggregationType: undefined,
                chartDisplayType: undefined,
                chartTimebox: undefined,
                title: ''
            }
        },

        chartComponentConfig: undefined,

        getSettingsFields: function () {
            this.chartSettings = this.chartSettings || Ext.create('Rally.apps.charts.burndown.BurnDownSettings', {
                app: this
            });

            return this.chartSettings.getFields();
        },

        onScopeChange: function (scope) {
            if (!this.ignoreOnScopeChange) {
                this._rebuildChartForScope(scope.getRecord().get('_ref'));
            }
        },
        _buildLayout: function () {
  
            this.add(Ext.create('App.Information')._generate_Tabs());
            //this._mask();
        },

        launch: function () {
            this._buildLayout();
            if (this._settingsInvalid()) {
                this.fireEvent('settingsneeded', this);
                return;
            }
            this.customScheduleStates = null;
            this.chartComponentConfig = Ext.create('Rally.apps.charts.burndown.BurnDownChart', this).defaultChartComponentConfig();

            Ext.create('Rally.apps.charts.IntegrationHeaders', this).applyTo(this.chartComponentConfig.storeConfig);

            this._addHelpComponent();
            this._loadUserStoryModel();
            this._saveScopeType();
            this.callParent(arguments);

            if (!this.isOnScopedDashboard()) {
                this.ignoreOnScopeChange = true;
                this._getScopePicker().on('ready', this._loadScopePreference, this, {
                    single: true
                });
            }
        },

        _addHelpComponent: function () {
            this.down('#header').add(this._buildHelpComponent());
        },

        _buildHelpComponent: function () {
            return Ext.create('Ext.Component', {
                renderTpl: Rally.util.Help.getIcon({
                    cls: Rally.util.Test.toBrowserTestCssClass(this.help.cls),
                    id: this.help.id
                })
            });
        },

        _rebuildChartForScope: function (scopeRef) {
            this._destroyChart();

            this._saveScopePreference(scopeRef);
            this._loadScopeObject(scopeRef);
        },

        _destroyChart: function () {
            this.remove('burndownchart');
        },

        _saveScopePreference: function (scopeRef) {
            if (!this.isOnScopedDashboard()) {
                var settings = {};
                settings[this._getScopeType()] = scopeRef;

                Rally.data.PreferenceManager.update({
                    appID: this.getContext().get('appID'),
                    settings: settings,
                    scope: this
                });
            }
        },

        _loadScopePreference: function (picker) {
            Rally.data.PreferenceManager.load({
                appID: this.getContext().get('appID'),
                success: function (preferences) {
                    var scopeRef = preferences[this._getScopeType()];
                    if (!scopeRef || scopeRef === 'undefined') {
                        var pickerRecord = picker.getRecord();
                        if (pickerRecord) {
                            scopeRef = pickerRecord.get('_ref');
                            this._saveScopePreference(scopeRef);
                        }
                    }
                    this.ignoreOnScopeChange = false;

                    if (scopeRef && scopeRef !== 'undefined') {
                        this._setScopeValue(scopeRef);
                        scopeRef = this._getScopePicker().getValue();
                        if (scopeRef) {
                            this._rebuildChartForScope(scopeRef);
                        }
                    }
                },
                scope: this
            });
        },

        _setScopeValue: function (scopeRef) {
            this._getScopePicker().setValue(scopeRef);
        },

        _loadTimeboxes: function () {
            Ext.create('Rally.data.wsapi.Store', {
                model: this.scopeObject._type,
                filters: [{
                        property: 'Name',
                        operator: '=',
                        value: this.scopeObject.Name
                    },
                    {
                        property: this._getScopeObjectStartDateName(),
                        operator: '=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                    },
                    {
                        property: this._getScopeObjectEndDateName(),
                        operator: '=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                    }
                ],
                context: this.getContext().getDataContext(),
                fetch: ['ObjectID'],
                limit: Infinity,
                autoLoad: true,
                listeners: {
                    load: function (store, records) {
                        this._getTimeboxesInScope(store, records);
                    },
                    scope: this
                }
            });
        },

        _onScopeObjectLoaded: function (record) {
            this._setScopeFromData(record);

            this._updateChartTitle();
            this._updateYAxis();

            this._addDateBounds();
            this._addAggregationTypeToCalculator();
            this._loadTimeboxes();
        },

        _renderChartBasedOnType: function () {
            if (this._getScopeType() === 'release') {
                this._fetchIterations();
            } else {
                if (this.customScheduleStates === null) { // wait until we get the schedule states
                    this.deferredAddChart = this._addChart;
                } else {
                    this._addChart();
                }
            }
        },

        _setScopeFromData: function (record) {
            this.scopeObject = record.data;
        },

        _getTimeboxesInScope: function (store, records) {
            var storeConfig = this.chartComponentConfig.storeConfig;
            var type = Ext.String.capitalize(this._getScopeType());
            var oids = [];
            var i;

            this.timeboxes = store.getItems();
            this._clearStoreConfig(storeConfig);

            for (i = 0; i < this.timeboxes.length; i++) {
                oids.push(this.timeboxes[i].ObjectID);
            }
            storeConfig.find[type] = {
                '$in': oids
            };

            this._renderChartBasedOnType();

        },

        _addChartWithIterationLines: function () {
            this._addChart();
            this.down('rallychart').on('snapshotsAggregated', this._addIterationLines, this);
        },

        _onIterationsLoaded: function (store) {
            this.iterations = store.getItems();

            if (this.customScheduleStates === null) {
                this.deferredAddChart = this._addChartWithIterationLines;
            } else {
                this._addChartWithIterationLines();
            }
        },

        _addDateBounds: function () {
            this._addDateBoundsToQuery();
            this._addDateBoundsToCalculator();
        },

        _addDateBoundsToQuery: function () {

        },

        _getNow: function () {
            return new Date();
        },

        _addDateBoundsToCalculator: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            var endDate = this._getScopeObjectEndDate();
            var now = this._getNow();
            calcConfig.startDate = Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true);
            if (now > this._getScopeObjectStartDate() && now < this._getScopeObjectEndDate()) {
                endDate = now;
            }
            calcConfig.endDate = Rally.util.DateTime.toIsoString(endDate, true);
            // S53625: If the time-box has ended, disable the projection line
            if (now > this._getScopeObjectEndDate()) {
                calcConfig.enableProjections = false;
            } else {
                calcConfig.enableProjections = true;
            }
            // add scopeEndDate, which may or may not be the same as endDate
            calcConfig.scopeEndDate = this._getScopeObjectEndDate();
        },

        _addAggregationTypeToCalculator: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            calcConfig.chartAggregationType = this.getSetting('chartAggregationType');
        },

        _updateCompletedScheduleStates: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            calcConfig.completedScheduleStateNames = this.customScheduleStates;
        },

        _loadScopeObject: function (scopeRef) {
            Rally.data.ModelFactory.getModel({
                type: this._getScopeType(),

                context: {
                    workspace: this.getContext().getWorkspaceRef(),
                    project: null
                },
                success: function (model) {
                    model.load(Rally.util.Ref.getOidFromRef(scopeRef), {
                        success: function (record) {
                            this._onScopeObjectLoaded(record);
                        },
                        scope: this
                    });
                },
                scope: this
            });
        },

        _fetchIterations: function () {
            var store = Ext.create('Rally.data.wsapi.Store', {
                model: Ext.identityFn('Iteration'),
                filters: [{
                        property: 'StartDate',
                        operator: '>=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                    },
                    {
                        property: 'EndDate',
                        operator: '<=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                    }
                ],
                context: {
                    workspace: this.getContext().getWorkspaceRef(),
                    project: this.getContext().getProjectRef()
                },
                fetch: ['Name', 'StartDate', 'EndDate'],
                limit: Infinity
            });

            store.on('load', this._onIterationsLoaded, this);
            store.load();
        },

        _areIterationsEqual: function (iteration1, iteration2) {
            return iteration1.Name === iteration2.Name &&
                iteration1.StartDate === iteration2.StartDate &&
                iteration1.EndDate === iteration2.EndDate;
        },

        _addIterationLines: function (chart) {
            var axis = chart.chartConfig.xAxis;
            var categories = chart.chartData.categories;
            var i, j;
            var uniqueIterations = [];
            var unique;

            axis.plotLines = [];
            axis.plotBands = [];

            for (i = 0; i < this.iterations.length; i++) {
                unique = true;
                for (j = 0; j < uniqueIterations.length; j++) {
                    if (this._areIterationsEqual(uniqueIterations[j], this.iterations[i])) {
                        unique = false;
                        break;
                    }
                }
                if (unique === true) {
                    uniqueIterations.push(this.iterations[i]);
                }
            }

            for (i = 0; i < uniqueIterations.length; i++) {
                axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[i], false));
                axis.plotBands.push(this._getPlotBand(categories, uniqueIterations[i], i % 2 !== 0));
            }

            if (uniqueIterations.length > 0) {
                axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[uniqueIterations.length - 1], true));
            }
        },
        _buildLabelText: function (iteration) {
            var labelSetting = this.getSetting("showLabels");

            var text = '';
            if (labelSetting) {
                text = iteration.Name || '';
            }
            return text;
        },

        _getPlotBand: function (categories, iteration, shouldColorize) {
            var startDate = this.dateStringToObject(iteration.StartDate);
            var endDate = this.dateStringToObject(iteration.EndDate);

            var label = {
                text: this._buildLabelText(iteration),
                align: 'center',
                rotation: 0,
                y: -7
            };

            return {
                color: shouldColorize ? '#F2FAFF' : '#FFFFFF',
                from: this._getNearestWorkday(categories, startDate),
                to: this._getNearestWorkday(categories, endDate),

                label: label
            };
        },

        _getNearestWorkday: function (categories, date) {
            var dateStr = Ext.Date.format(date, 'Y-m-d');
            var index = categories.indexOf(dateStr);
            if (index === -1) {
                var workdays = this._getWorkspaceConfiguredWorkdays();
                if (workdays.length < 1) {
                    return -1;
                }
                // date not in categories (probably) means it falls on a non-workday...back up to the next previous workday
                while (workdays.indexOf(Ext.Date.format(date, 'l')) === -1 && date > this._getScopeObjectStartDate()) {
                    date = Ext.Date.add(date, Ext.Date.DAY, -1);
                    dateStr = Ext.Date.format(date, 'Y-m-d');
                    index = categories.indexOf(dateStr);
                }
            }
            return index;
        },

        _getPlotLine: function (categories, iteration, lastLine) {
            var dateObj;
            var dateIndex;

            if (lastLine) {
                dateObj = this.dateStringToObject(iteration.EndDate);
            } else {
                dateObj = this.dateStringToObject(iteration.StartDate);
            }

            dateIndex = this._getNearestWorkday(categories, dateObj);

            return {
                color: '#BBBBBB',
                dashStyle: 'ShortDash',
                width: 2,
                zIndex: 3,
                value: dateIndex
            };
        },

        _addChart: function () {
            this._updateCompletedScheduleStates();
            this._updateChartConfigDateFormat();
            this._updateChartConfigWorkdays();
            var chartComponentConfig = Ext.Object.merge({}, this.chartComponentConfig);

            this.add(chartComponentConfig);
            this.down('rallychart').on('snapshotsAggregated', this._onSnapshotDataReady, this);
        },



        _onSnapshotDataReady: function (chart) {
            this._updateDisplayType(chart);
            this._updateXAxis(chart);
        },

        _updateDisplayType: function (chart) {
            var series = chart.chartData.series;
            var displayType = this.getSetting('chartDisplayType');
            var i;

            for (i = 0; i < series.length; i++) {
                if (this._seriesFollowsDisplayType(series[i])) {
                    series[i].type = displayType;
                }
            }
        },

        _seriesFollowsDisplayType: function (series) {
            return series.name.indexOf('Ideal') === -1 && series.name.indexOf('Prediction') === -1;
        },

        _updateYAxis: function () {
            this._updateYAxisTitle();
            this._updateYAxisConfig();
        },

        _updateYAxisTitle: function () {
            var chartConfig = this.chartComponentConfig.chartConfig;
            chartConfig.yAxis = [{}];
            chartConfig.yAxis[0].title = {
                text: this._getAxisTitleBasedOnAggregationType()
            };
        },

        _updateYAxisConfig: function () {
            var axis = this.chartComponentConfig.chartConfig.yAxis[0];
            axis.min = 0;
            axis.labels = {
                x: -5,
                y: 4
            };
        },

        _updateXAxis: function (chart) {
            if (this.container.dom.offsetWidth < 1000) {
                chart.chartConfig.xAxis.labels.staggerLines = 2;
            }
            chart.chartConfig.xAxis.labels.step = Math.round(chart.chartData.categories.length / 100);
            chart.chartConfig.xAxis.tickInterval = this._configureChartTicks(chart.chartData.categories.length);
        },

        _configureChartTicks: function (days) {
            var pixelTickWidth = 125,
                appWidth = this.getWidth(),
                ticks = Math.floor(appWidth / pixelTickWidth);

            return Math.ceil(days / ticks);
        },

        _getAxisTitleBasedOnAggregationType: function () {
            var aggregationType = this.getSetting('chartAggregationType');
            if (aggregationType === 'storycount') {
                return 'Count';
            } else {
                return 'Plan Estimate';
            }
        },

        _updateChartConfigDateFormat: function () {
            var self = this;

            this.chartComponentConfig.chartConfig.xAxis.labels.formatter = function () {
                return self._formatDate(self.dateStringToObject(this.value));
            };
        },

        _updateChartConfigWorkdays: function () {
            this.chartComponentConfig.calculatorConfig.workDays = this._getWorkspaceConfiguredWorkdays().split(',');
        },

        _parseRallyDateFormatToHighchartsDateFormat: function () {
            var dateFormat = this._getUserConfiguredDateFormat() || this._getWorkspaceConfiguredDateFormat();

            for (var i = 0; i < this.dateFormatters.length; i++) {
                dateFormat = dateFormat.replace(this.dateFormatters[i].key, this.dateFormatters[i].value);
            }

            return dateFormat;
        },

        _formatDate: function (date) {
            if (!this.dateFormat) {
                this.dateFormat = this._parseRallyDateFormatToHighchartsDateFormat();
            }

            return Highcharts.dateFormat(this.dateFormat, date.getTime());
        },

        _getUserConfiguredDateFormat: function () {
            return this.getContext().getUser().UserProfile.DateFormat;
        },

        _getWorkspaceConfiguredDateFormat: function () {
            return this.getContext().getWorkspace().WorkspaceConfiguration.DateFormat;
        },

        _getWorkspaceConfiguredWorkdays: function () {
            return this.getContext().getWorkspace().WorkspaceConfiguration.WorkDays;
        },

        _updateChartTitle: function () {
            this.chartComponentConfig.chartConfig.title = this._buildChartTitle();
        },

        _buildChartTitle: function () {
            var widthPerCharacter = 10;
            var totalCharacters = Math.floor(this.getWidth() / widthPerCharacter);
            var title = this._getDefaultTitle();
            var align = 'center';

            if (this.scopeObject) {
                title = this.scopeObject.Name;
            }

            if (totalCharacters < title.length) {
                title = title.substring(0, totalCharacters) + '...';
                align = 'left';
            }

            return {
                text: title + ' Burn Delta',
                align: align,
                margin: 30
            };
        },

        _getDefaultTitle: function () {
            return Ext.String.capitalize(this._getScopeType());
        },

        _settingsInvalid: function () {
            var chartAggregationType = this.getSetting('chartAggregationType'),
                chartDisplayType = this.getSetting('chartDisplayType'),
                chartTimebox = this.getSetting('chartTimebox');

            var invalid = function (value) {
                return !value || value === 'undefined';
            };

            return invalid(chartAggregationType) || invalid(chartDisplayType) ||
                this._chartTimeboxInvalid(chartTimebox);
        },

        _chartTimeboxInvalid: function (chartTimebox) {
            if (this.context.getTimeboxScope()) {
                return false;
            }

            return !chartTimebox || chartTimebox === 'undefined';
        },

        _saveScopeType: function () {
            this.scopeType = this._getScopeType();
        },

        _getScopeType: function () {
            if (this.isOnScopedDashboard()) {
                return this._getDashboardScopeType();
            } else {
                return this._getSavedScopeType();
            }
        },

        _getDashboardScopeType: function () {
            return this.getContext().getTimeboxScope().getType();
        },

        _getSavedScopeType: function () {
            return this.getSetting('chartTimebox');
        },

        _getScopePicker: function () {
            if (this.isOnScopedDashboard()) {
                return this.getContext().getTimeboxScope();
            } else {
                return this.down('rally' + this._getScopeType() + 'combobox');
            }
        },

        _getScopeObjectStartDateName: function () {
            if (!this.scopeObject) {
                return '';
            } else if (this.scopeObject._type === 'release') {
                return 'ReleaseStartDate';
            } else {
                return 'StartDate';
            }
        },

        _getScopeObjectEndDateName: function () {
            if (!this.scopeObject) {
                return '';
            } else if (this.scopeObject._type === 'release') {
                return 'ReleaseDate';
            } else {
                return 'EndDate';
            }
        },

        _getScopeObjectStartDate: function () {
            if (!this.scopeObject) {
                return this._getNow();
            } else if (this.scopeObject._type === 'release') {
                return this.scopeObject.ReleaseStartDate;
            } else {
                return this.scopeObject.StartDate;
            }
        },

        _getScopeObjectEndDate: function () {
            if (!this.scopeObject) {
                return this._getNow();
            } else if (this.scopeObject._type === 'release') {
                return this.scopeObject.ReleaseDate;
            } else {
                return this.scopeObject.EndDate;
            }
        },

        _clearStoreConfig: function (storeConfig) {
            if (storeConfig.find.hasOwnProperty('Release')) {
                delete storeConfig.find.Release;
            }

            if (storeConfig.find.hasOwnProperty('Iteration')) {
                delete storeConfig.find.Iteration;
            }
        },

        _loadUserStoryModel: function () {
            Rally.data.ModelFactory.getModel({
                type: "UserStory",
                context: this._getContext(),
                success: function (model) {
                    this._getScheduleStateValues(model);
                },
                scope: this
            });
        },

        _getContext: function () {
            return {
                workspace: this.context.getWorkspaceRef(),
                project: null
            };
        },

        _getScheduleStateValues: function (model) {
            var scheduleStates = model.getField('ScheduleState').getAllowedStringValues();

            this.customScheduleStates = scheduleStates.slice(scheduleStates.indexOf('Completed'), scheduleStates.length);

            if (this.deferredAddChart) {
                this.deferredAddChart.call(this);
            }
        }
    });
}());
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownCalculator", {
        extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",
        mixins: [
            "Rally.apps.charts.DateMixin"
        ],

        getDerivedFieldsOnInput: function () {
            var completedStates = this.config.completedScheduleStateNames,
                aggregationType = this.config.chartAggregationType;

            return [
                {
                    "as": "RemainingPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if(completedStates.indexOf(ss) < 0) {
                            if(aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                },
                {
                    "as": "AcceptedPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if (completedStates.indexOf(ss) > -1) {
                            if (aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                },
                {
                    "as": "CompletedPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if (completedStates.indexOf(ss) > -1) {
                            if (aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                }
            ];
        },

        getMetrics: function () {
            return [
                {
                    "field": "RemainingPoints",
                    "as": "To Do",
                    "f": "sum"
                },
                {
                    "field": "AcceptedPoints",
                    "as": "Accepted",
                    "f": "sum"
                },
                {
                    "field": "CompletedPoints",
                    "as": "Completed",
                    "f": "sum"
                }
            ];
        },

        getSummaryMetricsConfig: function () {
            return [
                {
                    'as': 'Scope_max',
                    'f': function(seriesData) {
                            var max = 0, i = 0;
                            for (i=0;i<seriesData.length;i++) {
                                if(seriesData[i].Completed + seriesData[i]['To Do'] > max) {
                                    max = seriesData[i].Completed + seriesData[i]['To Do'];
                                }
                            }
                            return max;
                         }
                }
            ];
        },

        getDerivedFieldsAfterSummary: function () {
            return  [
                {
                    "as": "Ideal",
                    "f": function (row, index, summaryMetrics, seriesData) {
                        var max = summaryMetrics.Scope_max,
                            increments = seriesData.length - 1,
                            incrementAmount;
                        if(increments === 0) {
                            return max;
                        }
                        incrementAmount = max / increments;
                        return Math.floor(100 * (max - index * incrementAmount)) / 100;
                    },
                    "display": "line",
                    "dashStyle": "Dash"
                },
                {
                    "as": "Prediction",
                    "f": function (row, index, summaryMetrics, seriesData) {
                        return null;
                    },
                    "display": "line",
                    "dashStyle": "Dash"
                }
            ];
        },

        getProjectionsConfig: function () {
            var days = (this.scopeEndDate.getTime() -
                Rally.util.DateTime.fromIsoString(this.startDate).getTime()) / (24*1000*60*60);
            var doubleTimeboxEnd = Ext.Date.add(Rally.util.DateTime.fromIsoString(this.startDate), Ext.Date.DAY, (Math.floor(days) * 2) - 1);
            var timeboxEnd = Ext.Date.add(this.scopeEndDate, Ext.Date.DAY, -1);
            if(this.projectionsConfig === undefined) {
                this.projectionsConfig = {
                    doubleTimeboxEnd: doubleTimeboxEnd,
                    timeboxEnd: timeboxEnd,

                    series: [
                        {
                            "as": "Prediction",
                            "field": "To Do"
                        }
                    ],
                    continueWhile: function (point) {
                        var dt = Rally.util.DateTime.fromIsoString(point.tick);
                        var end = (this.series[0].slope >= 0) ? this.timeboxEnd : this.doubleTimeboxEnd;
                        return point.Prediction > 0 && dt < end;
                    }
                };
            }
            return this.projectionsConfig;
        },

        _firstNonZero: function(data) {
             var i;
             for(i=0;i<data.length;i++) {
                if(data[i] > 0) {
                    return i;
                }
             }
             return 0;
        },

        _leastSquares: function(todoValues, firstIndex, lastIndex) {
            var n = (lastIndex + 1) - firstIndex;
            var i;
            var sumx = 0.0, sumx2 = 0.0, sumy = 0.0, sumy2 = 0.0, sumxy = 0.0;
            var slope, yintercept;

            //Compute sums of x, x^2, y, y^2, and xy
            for (i = firstIndex; i <= lastIndex; i++) {
                sumx  = sumx  + i;
                sumx2 = sumx2 + i * i;
                sumy  = sumy  + todoValues[i];
                sumy2 = sumy2 + todoValues[i] * todoValues[i];
                sumxy = sumxy + i * todoValues[i];
            }
            slope = (n * sumxy - sumx * sumy) / (n * sumx2 - sumx * sumx);
            yintercept = (sumy * sumx2 - sumx * sumxy) / (n * sumx2 - sumx * sumx);

            return {slope: slope, yintercept: yintercept};
        },

        runCalculation: function (snapshots) {
            var chartData = this.callParent(arguments);

            if(chartData && chartData.projections && chartData.projections.series[0].slope > 0) {
            // if the slope is positive, try using least squares.  If that's also positive, then use the first result
                var todoData = chartData.series[0].data;
                var firstTodoIndex = this._firstNonZero(todoData),
                    lastTodoIndex = (todoData.length - 1) - chartData.projections.pointsAddedCount;

                var results = this._leastSquares(todoData, firstTodoIndex, lastTodoIndex);

                // override the prediction line only if least squares says the slope isn't positive
                if(results.slope <= 0) {
                    this.projectionsConfig.series[0].slope = results.slope;

                    chartData = this.callParent(arguments);

                    // project the plot back to the first todo value
                    chartData.series[3].data[firstTodoIndex] = ((results.slope * firstTodoIndex) + results.yintercept) + (chartData.series[3].data[lastTodoIndex] - ((results.slope * lastTodoIndex) + results.yintercept));
                    chartData.series[3].connectNulls = true;
                    this.projectionsConfig = undefined;
                } else {
                // DE18732, if the slope is up, truncate it at 1.25 of the max Ideal
                    var predictionCeiling = 1.25 * chartData.series[2].data[0];
                    if (_.max(chartData.series[3].data) > predictionCeiling) {
                        var i;
                        var maxVal = predictionCeiling;
                        for(i=0;i < chartData.series[3].data.length;i++) {
                            if(chartData.series[3].data[i] > predictionCeiling) {
                                chartData.series[3].data[i] = maxVal;
                                maxVal = null;
                            }
                        }
                    }
                }

            }

            if(new Date() < this.scopeEndDate) {
                this._recomputeIdeal(chartData, this.scopeEndDate);
            }

            return chartData;
        },

        _recomputeIdeal: function(chartData, endDate) {
             var index;
             if(chartData.categories.length < 1) {
                return;
             }
             if(this.workDays.length < 1) {
                return;
             }

             var lastDate = Ext.Date.parse(chartData.categories[chartData.categories.length - 1], 'Y-m-d');
             if(endDate > lastDate) {
                // the scopeEndDate date wasn't found in the current categories...we need to extend categories to include it
                // (honoring "workDays").

                index = chartData.categories.length;
                var dt = Ext.Date.add(lastDate, Ext.Date.DAY, 1);
                while (dt < endDate) {
                    while (this.workDays.indexOf(Ext.Date.format(dt, 'l')) === -1) {
                        dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                    }
                    if (dt < endDate) {
                        chartData.categories[index++] = Ext.Date.format(dt, 'Y-m-d');
                    }
                    dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                }
                index = chartData.categories.length - 1;
             } else {
                 // it is in "scope"...set index to the index of the last workday in scope
                 index = this._indexOfDate(chartData, endDate);
                 if(index === -1) {
                    // it's in "scope", but falls on a non-workday...back up to the previous workday
                    while (this.workDays.indexOf(Ext.Date.format(endDate, 'l')) === -1) {
                        endDate = Ext.Date.add(endDate, Ext.Date.DAY, -1);
                        index = this._indexOfDate(chartData, endDate);
                    }
                 }
             }
             if(index < 0) {
                return;
             }
             // set first and last point, and let connectNulls fill in the rest
             var i;
             var seriesData = chartData.series[2].data;
             for (i=1;i<index;i++) {
                seriesData[i] = null;
             }
             seriesData[index] = 0;
        },

        _indexOfDate: function(chartData, date) {
             var dateStr = Ext.Date.format(date, 'Y-m-d');
             return chartData.categories.indexOf(dateStr);
        },

        _removeFutureSeries: function (chartData, seriesIndex, dayIndex) {
            if(chartData.series[seriesIndex].data.length > dayIndex) {
                while(++dayIndex < chartData.series[seriesIndex].data.length) {
                    chartData.series[seriesIndex].data[dayIndex] = null;
                }
            }
        },

        _projectionsSlopePositive: function (chartData) {
            if(chartData.projections && chartData.projections.series) {
                return chartData.projections.series[0].slope >= 0;
            }

            return true;
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.charts.burndown.ReleaseBurnDownApp', {
        extend: 'Rally.apps.charts.burndown.BurnDownApp',
        help: {
            id: 278
        },
        integrationHeaders : {
            name: 'Release Burndown'
        }
    });
}());


            Rally.launchApp('Rally.apps.charts.burndown.ReleaseBurnDownApp', {
                name:"Burndown",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .burndown-app .chartControls,
.app-settings .settings-form .paddedSettingCmp {
  margin: 15px;
  border: 0px;
}
.burndown-app .chartControls .rui-triggerfield {
  display: inline-block;
}
.burndown-app .chartControls label {
  display: inline-block;
  font-size: 1.2em;
  margin: 3px 8px;
}
.portfolio-cfd-app,
.portfolio-burnup-app,
.burndown-app {
  margin: 10px;
  padding-right: 20px;
  background-color: transparent;
}
.portfolio-cfd-app .rally-help-icon,
.burndown-app .rally-help-icon,
.portfolio-burnup-app .rally-help-icon,
.chart-app .rally-help-icon {
  float: right;
}
.portfolio-cfd-app .chart,
.portfolio-burnup-app .chart {
  min-height: 2em;
}
.app-settings .settings-form .piButton {
  padding: 5px 15px 7px 15px;
  z-index: 101;
  margin-bottom: 10px;
}
.app-settings .settings-form .piDisplayField {
  background-color: #e2eff6;
  margin-left: -10px;
  min-width: 250px;
  padding: 5px 20px 3px 25px;
  z-index: 100;
  -webkit-border-radius: 20px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}
.app-settings .settings-form .settingsLabel {
  display: block;
  font-family: NotoSansBold, Helvetica, Arial;
  font-weight: normal;
  min-height: 20px;
  text-transform: uppercase;
  width: 100px;
}
table.settings-showLabels label {
  white-space: nowrap;
  width: auto;
}
table.settings-showLabels td {
  width: 130px;
}
.schedule-state-selector .x-boundlist-selected .x-form-checkbox {
  background-position: 0 -13px;
}
.statefieldvalue-boundlist-item img.stateFieldValue {
  background: transparent url('checkbox.gif');
  height: 13px;
  width: 13px;
}
.statefieldvalue-boundlist-selected img.stateFieldValue {
  background: transparent url('checkbox.gif');
  height: 13px;
  width: 13px;
  background-position-x: 0px;
  background-position-y: -13px;
}

    </style>

    <style type="text/css">
        .app {
  /* Add app styles here */
}
.fixTabMargins {
  margin: 0;
  padding: 0;
  height: 200px;
}
.x-tab-bar {
  background-color: white;
  border: none;
}
.x-panel-default {
  border: none;
}
.x-panel-body-default {
  border: none;
}
.x-tab-bar .x-tab-default .x-tab-inner {
  color: black;
}
.x-tab-bar .x-tab-active .x-tab-inner {
  color: black;
  text-decoration: underline;
}
h2 {
  margin: 0px;
  color: black;
  font-size: 18px;
  font-weight: bold;
  font-family: Gill Sans Extrabold, sans-serif;
}
h3 {
  margin: 0px;
  color: #666;
  font-size: 16px;
  font-weight: normal;
  font-family: Gill Sans Extrabold, sans-serif;
}
p {
  margin: 0px;
  color: #555;
  font-size: 20px;
  font-weight: normal;
  font-family: Gill Sans Extrabold, sans-serif;
}
li {
  list-style-type: disc;
}
ul,
ol {
  margin: 0;
  padding: 0;
}
/* Divs */
/* About */
.divTable {
  margin: 5px 0;
  display: table;
  width: 100%;
}
.divTableBody {
  width: 100%;
}
.divTableRowHeader {
  display: table-row;
}
.divTableRowContent {
  display: table-row;
}
.divTableCellContent,
.divTableCellContent_stretched,
.divTableCellHeader,
.divTableCellHeader_stretched {
  display: table-cell;
  /*font-family: Arial, sans-serif;*/
  font-family: Gill Sans Extrabold, sans-serif;
  overflow: hidden;
  font-weight: normal;
  word-break: normal;
  vertical-align: top;
  width: 20%;
  padding: 10px;
}
.divTableCellHeader,
.divTableCellHeader_stretched {
  font-size: 18px;
  font-weight: bold;
  border-bottom: 4px solid dimgrey;
}
.divTableCellContent_stretched,
.divTableCellHeader_stretched {
  width: 40%;
}
.divTableCellContent,
.divTableCellContent_stretched {
  font-size: 14px;
  font-weight: normal;
}
.divSpacer {
  width: 20px;
}
.headerBg2 {
  background: #eee;
}
.headerBg1 {
  background: white;
}
.contentBg2 {
  background: #eee;
}
.contentBg1 {
  background: white;
}

    </style>
</head>
<body>
</body>
</html>
