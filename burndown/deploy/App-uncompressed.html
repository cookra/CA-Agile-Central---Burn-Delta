<!DOCTYPE html>
<html>
<head>
    <title>Burndown</title>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.3.3/jspdf.debug.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.DateMixin", {

        dateFormatters: [
            {key: "MMM", value: "%b"},
            {key: "MM", value: "%m"},
            {key: "dd", value: "%d"},
            {key: "yyyy", value: "%Y"}
        ],

        dateToStringDisplay: function (date) {
            return Ext.Date.format(date, 'm/d/Y');
        },

        dateToString: function (date) {
            return Ext.Date.format(date, 'Y-m-d\\TH:i:s.u\\Z');
        },

        dateStringToObject: function (dateStr) {
            var finalIndex = dateStr.indexOf('T'),
                dateObj;

            if (finalIndex > -1) {
                dateStr = dateStr.slice(0, dateStr.indexOf('T'));
            }

            dateObj = this._splitDateParts(dateStr);

            return new Date(dateObj.year, dateObj.month, dateObj.day);
        },

        _getMonth: function(month) {
            var monthMap = { jan: 0, feb: 1, mar: 2, apr: 3,
                             may: 4, jun: 5, jul: 6, aug: 7,
                             sep: 8, oct: 9, nov: 10, dec: 11 };
            if(isNaN(month)) {
                try {
                    month = monthMap[month.toLowerCase()];
                } catch(err) { }
            } else {
                month = parseInt(month, 10) - 1;
            }

            return month.toString();
        },

        _objectFromYearFirstDate: function (dateArray) {
            var month = 0,
                day = 0,
                year = 0;

            if (dateArray.length !== 3) {
                return { year: year, month: month, day: day };
            }

            year = dateArray[0];
            month = this._getMonth(dateArray[1]);
            day = dateArray[2];

            return {
                year: year,
                month: month,
                day: day
            };
        },

        _objectFromMonthFirstDate: function (dateArray) {
            var month = 0,
                day = 0,
                year = 0;

            if (dateArray.length !== 3) {
                return { year: year, month: month, day: day };
            }

            month = this._getMonth(dateArray[0]);
            day = dateArray[1];
            year = dateArray[2];

            return {
                month: month,
                day: day,
                year: year
            };
        },

        _shouldSplitOnDash: function (dateStr) {
            return dateStr.split('-').length === 3;
        },

        _splitDateParts: function (dateStr) {
            if (this._shouldSplitOnDash(dateStr)) {
                return this._objectFromYearFirstDate(dateStr.split('-'));
            }
            else {
                return this._objectFromMonthFirstDate(dateStr.split('/'));
            }
        }

    });

}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.IntegrationHeaders", {

        keyConverters : {
            name : function() { return 'X-RallyIntegrationName'; },
            vendor : function() { return 'X-RallyIntegrationVendor'; },
            platform : function() { return 'X-RallyIntegrationPlatform'; },
            os : function() { return 'X-RallyIntegrationOS'; },
            version : function() { return 'X-RallyIntegrationVersion'; },
            library : function() { return 'X-RallyIntegrationLibrary'; }
        },

        constructor: function(config) {
            this.headers = {
                name : 'A2 Chart',
                vendor : 'Rally Software'
            };

            Ext.merge(this.headers, config.integrationHeaders || {});
            this.callParent(config);
        },
        withName : function(nm) {
            this.headers.name = nm || this.headers.name;
            return this;
        },
        withVendor : function(v) {
            this.headers.vendor = v || this.headers.vendor;
            return this;
        },
        withPlatform : function(newPlatform) {
            this.headers.platform = newPlatform || this.headers.platform;
            return this;
        },
        withVersion : function(newVersion) {
            this.headers.version = newVersion || this.headers.version;
            return this;
        },
        withOS : function(newOS) {
            this.headers.os = newOS || this.headers.os;
            return this;
        },
        withLibrary : function(newLibrary) {
            this.headers.library = newLibrary || this.headers.library;
            return this;
        },
        applyTo : function(config) {
            config.headers = config.headers || {};
            Ext.merge(config.headers, this.build());
            return config;
        },
        build : function() {
            var h = {};
            for (var k in this.headers) {
                if (this.headers.hasOwnProperty(k)) {
                    if (this.headers[k] === null) { continue; }
                    var key = this._keyConverter(k)(k);
                    h[key] = this.headers[k];
                }
            }
            return h;
        },
        _keyConverter: function(key) {
            if (this.keyConverters.hasOwnProperty(key)) {
                return this.keyConverters[key];
            } else {
                return function(x) {return x;};
            }
        }
    });
}());

                (function() {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.RadioGroupSetting", {
        extend: "Ext.form.FieldContainer",

        config: {
            settingName: undefined
        },

        constructor: function(config) {
            this.mergeConfig(config);
            this.callParent(arguments);
        },

        getSetting: function() {
            return this.settingsParent.app.getSetting(this.settingName);
        },

        setRadioValue: function (cmp) {
            this.setRadioToCustomValue(cmp, this.getSetting());
        },

        setRadioToCustomValue: function (cmp, customValue) {
            var value = {};
            value[cmp.name] = customValue;
            cmp.setValue(value);
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.ChartDisplayTypePicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.chartdisplaytypepicker",

        mixins: [
            "Ext.form.field.Field"
        ],

        config: {
            settingName: "chartDisplayType"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this.add(this._getPicker());
        },

        _getPicker: function () {
            return {
                xtype: "radiogroup",
                name: this.settingName,
                columns: [160, 100],
                vertical: false,
                items: [
                    { boxLabel: "Area", name: this.settingName, inputValue: "area"},
                    { boxLabel: "Column", name: this.settingName, inputValue: "column" },
                    { boxLabel: "Line", name: this.settingName, inputValue: "line" },
                    { boxLabel: "Spline", name: this.settingName, inputValue: "spline", checked: true  },
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                }
            };
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.SettingsChangeMixin", {

        sendSettingsChange: function(artifact) {
            if (this.settingsParent) {
                this.settingsParent.sendSettingsChange(artifact, this);
            }
        },

        receiveSettingsChange: function(artifact) {

        }

    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.DataTypePicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.chartdatatypepicker",

        mixins: [
            "Ext.form.field.Field",
            "Rally.apps.charts.settings.SettingsChangeMixin"
        ],

        config: {
            settingName: "chartAggregationType"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this.add(this._addRadioGroup());
        },

        _addRadioGroup: function () {
            return {
                xtype: "radiogroup",
                name: this.settingName,
                columns: [160, 100],
                vertical: false,
                items: [
                    { boxLabel: "Story Plan Estimate", name: this.settingName, inputValue: "storypoints", checked: true },
                    { boxLabel: "Story Count", name: this.settingName, inputValue: "storycount" }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                }
            };
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.settings.TimeboxPicker", {
        extend: "Rally.apps.charts.settings.RadioGroupSetting",
        alias: "widget.charttimeboxpicker",

        mixins: [
            "Ext.form.field.Field"
        ],

        config: {
            settingName: "chartTimebox"
        },

        settingsParent: undefined,

        initComponent: function () {
            this.callParent(arguments);
            this._addRadioGroup();
        },

        _addRadioGroup: function () {
            this.add({
                xtype: "radiogroup",
                name: this.settingName,
                itemId: this.settingName,
                label: "Level",
                columns: [160, 100, 100],
                vertical: false,
                items: [
                    //{ boxLabel: "Release", name: this.settingName, inputValue: "release", checked: true },
                    { boxLabel: "Iteration", name: this.settingName, inputValue: "iteration", checked: true }
                ],
                listeners: {
                    beforerender: this.setRadioValue,
                    scope: this
                },
                config: {
                    cls: "levelchooser"
                }
            });
        }
    });
}());

                Ext.define('App.Information', {
    config: {
        // Versioning //
        pP_AppVersi: 'v2.0b',
        pP_AppStatus: 'beta',
        pP_AppliName: 'AC Burn Delta',
        pP_AppliDesc: 'Measures the Delta between users stories in To Do & Accepted',
        pP_AppliOwne: 'Richard Cook (Barclaycard LPM PMC)',
        pP_AppliDate: '2017-03-18: 11:47 GMT',
        // Git Repo Details
        pP_AppliRepo: 'not shared',
        // Emailer Contact Details
        pP_EmailAddr: 'richard.cook@barclaycard.co.uk',
        pP_EmailSubj: '*** [AC AC Burn Delta] Custom Application AC Support Request',
        pP_EmailBody: '========== Please add your comments above this line ==========',
        // Printing printCss
        pP_Print_Css: 'x',
        // Agile Central Internal colors
        pA_ACColours: ['#0096DB', '#004A9D', '#FF3C00', '#FF8D00', '#FFDC00', '#6F7376', 'white', '#FF0069', '#41006E', '#00710C'],
        // Barclays Corporate Colours
        pA_BCColours: ['#145FAC', '#437EA0', '#00AEEF', 'white', '#FFA000'],
        pA_MyColours: ['#d61551', '#c9506f', '#6a0b7', '#0e1026', '#e53118', '#262428', '#c9d940', '#d3272b', '#ea2b30', '#59595b', '#242021', '#ebe7e4', '#437EA0', '#41006E'],
    },
    _writePanelContent: function (whatAmI) {
        var content, output;
        spacerWidth = '20px';
        headerBorder = 'border-bottom: 4px solid dimgrey';
        if (whatAmI === 'tools') {
            output = [
                [{ margin: '0px', padding: '10px', color: 'black', background: '#eeeeee', type: 'header', width: '100%', height: '100%', fontWeight: 'bold', fontSize: '18px', txt: 'Tools' }],
                [{ margin: '0px', padding: '10px', color: 'black', background: '#eeeeee', type: 'contex', width: '100%', height: '100%', fontWeight: 'normal', fontSize: '12px', txt: 'If you require support for this application. please use the \'Contact Support\' button above.' }],
            ];
        }
        if (whatAmI === 'about') {
            // Left as 3d array to support future updates
            output = [
                [{margin:'0px',padding:'10px',color:'black',background:'#eeeeee',type:'header',width:'40%',height:'100%',fontWeight: 'bold',fontSize: '18px',txt:'About'}],
                [{margin:'0px',padding:'10px',color:'black',background:'#eeeeee',type:'contex',width:'40%',height:'100%',fontWeight: 'normal',fontSize: '12px',txt:'Displays the Burn delta between remaining and accepted user stories'}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'header',width:'20%',height:'100%',fontWeight: 'bold',fontSize: '18px',txt:'Configuration'}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'contex',width:'20%',height:'100%',fontWeight: 'normal',fontSize: '14px',txt:''}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'header',width:'20%',height:'100%',fontWeight: 'bold',fontSize: '18px',txt:'Data Types'}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'contex',width:'20%',height:'100%',fontWeight: 'normal',fontSize: '14px',txt:'<li>Planned Estimate</li><li>User Story Count</li>'}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'header',width:'20%',height:'100%',fontWeight: 'bold',fontSize: '18px',txt:'Chart Type'}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'contex',width:'20%',height:'100%',fontWeight: 'normal',fontSize: '14px',txt:'<li>Area</li><li>Column</li><li>Line</li><li>Split</li>'}],
              ];
        }
        if (whatAmI === 'usage') {
            output = [
                [{ margin: '0px', padding: '10px', color: 'black', background: '#eeeeee', type: 'header', width: '40%', height: '100%', fontWeight: 'bold', fontSize: '18px', txt: 'Usage' }],
                [{ margin: '0px', padding: '10px', color: 'black', background: '#eeeeee', type: 'contex', width: '40%', height: '100%', fontWeight: 'normal', fontSize: '12px', txt: 'This application can be used as a standalone page or as a custom app within a dashboard.' }],
                [{ margin: '0px', padding: '10px', color: 'black', background: 'white', type: 'header', width: '20%', height: '100%', fontWeight: 'bold', fontSize: '18px', txt: 'Deployment > > >' }],
                [{ margin: '0px', padding: '10px', color: 'black', background: 'white', type: 'contex', width: '20%', height: '100%', fontWeight: 'normal', fontSize: '14px', txt: '' }],
                [{ margin: '0px', padding: '10px', color: 'black', background: 'white', type: 'header', width: '20%', height: '100%', fontWeight: 'bold', fontSize: '18px', txt: '(A) Standalone' }],
                [{ margin: '0px', padding: '10px', color: 'black', background: 'white', type: 'contex', width: '20%', height: '100%', fontWeight: 'normal', fontSize: '14px', txt: '(1) Use application settings (2) Copy the source code and place into a new page (3) Set page filter to Iteration (4) Set page layout to single column (5) Add Custom HTML app (6) Use application settings to customise the chart'}],
                [{ margin: '0px', padding: '10px', color: 'black', background: 'white', type: 'header', width: '20%', height: '100%', fontWeight: 'bold', fontSize: '18px', txt: '(B) Custom App' }],
                [{ margin: '0px', padding: '10px', color: 'black', background: 'white', type: 'contex', width: '20%', height: '100%', fontWeight: 'normal', fontSize: '14px', txt: '(1) Use application settings (2) Copy the source code and place into a new Custom HTML app (3) Use application settings to customise the chart'}],
            ];
        }
        if (whatAmI === 'version') {
            output = [
                [{margin:'0px',padding:'10px',color:'black',background:'#eeeeee',type:'header',width:'40%',height:'100%',fontWeight: 'bold',fontSize: '18px',txt:'Version'}],
                [{margin:'0px',padding:'10px',color:'black',background:'#eeeeee',type:'contex',width:'40%',height:'100%',fontWeight: 'normal',fontSize: '12px',txt:this.pP_AppVersi}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'header',width:'20%',height:'100%',fontWeight: 'bold',fontSize: '18px',txt:'Status'}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'contex',width:'20%',height:'100%',fontWeight: 'normal',fontSize: '14px',txt:this.pP_AppStatus}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'header',width:'20%',height:'100%',fontWeight: 'bold',fontSize: '18px',txt:'Build Date'}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'contex',width:'20%',height:'100%',fontWeight: 'normal',fontSize: '14px',txt:this.pP_AppliDate}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'header',width:'20%',height:'100%',fontWeight: 'bold',fontSize: '18px',txt:'Owner'}],
                [{margin:'0px',padding:'10px',color:'black',background:'white',type:'contex',width:'20%',height:'100%',fontWeight: 'normal',fontSize: '14px',txt:this.pP_AppliOwne}],
            ];
        }
        if (whatAmI === 'support') {
            output = [
                [{ margin: '0px', padding: '10px', color: 'black', background: '#eeeeee', type: 'header', width: '100%', height: '100%', fontWeight: 'bold', fontSize: '18px', txt: 'Support' }],
                [{ margin: '0px', padding: '10px', color: 'black', background: '#eeeeee', type: 'contex', width: '100%', height: '100%', fontWeight: 'normal', fontSize: '12px', txt: 'If you require support for this application. please use the \'Contact Support\' button above.' }],
            ];
        }
        return this._divGenerator(output, spacerWidth, headerBorder);
    },
    _generate_Tabs: function () {
        var pA_MyColours = this.pA_MyColours;
        var pA_BCColours = this.pA_BCColours;
        var pP_AppVersi = this.pP_AppVersi;
        var config = [{
            panel_height: 160,
            panel_paddin: 10,
            panel_font_s: 15,
            panel_tools_tx: this._writePanelContent('tools'),
            panel_tools_tc: pA_MyColours[11],
            panel_tools_sc: this._stripecolorGenerator([{base_color:pA_MyColours[0],stripe_angle:45,blend:20}]),
            panel_about_tx: this._writePanelContent('about'),
            panel_about_tc: pA_MyColours[11],
            panel_about_sc: this._stripecolorGenerator([{base_color:pA_MyColours[13],stripe_angle:45,blend:20}]),
            panel_usage_tx: this._writePanelContent('usage'),
            panel_usage_tc: pA_MyColours[11],
            panel_usage_sc: this._stripecolorGenerator([{base_color:pA_MyColours[6],stripe_angle:45,blend:20}]),
            panel_version_tx: this._writePanelContent('version'),
            panel_version_tc: pA_MyColours[11],
            panel_version_sc: this._stripecolorGenerator([{base_color:pA_MyColours[9],stripe_angle:45,blend:20}]),
            panel_support_tx: this._writePanelContent('support'),
            panel_support_tc: pA_MyColours[11],
            panel_support_sc: this._stripecolorGenerator([{base_color:pA_MyColours[12],stripe_angle:45,blend:20}]),
            button_height: 25,
            button_support: pA_MyColours[8],
            button_print: pA_MyColours[6],
            button_excel: pA_MyColours[6],
            button_a_pdf: pA_MyColours[6],
            button_support_txt: pA_MyColours[3],
            button_print_txt: pA_MyColours[3],
            button_excel_txt: pA_MyColours[3],
            button_a_pdf_txt: pA_MyColours[3],
        }];
        // Build Details Container
        return this._panelGenerator(config);
    },
    _stripecolorGenerator: function (a){
        var stripe_color = Ext.create('Tools')._shadeBlendConvert(a[0].base_color, a[0].blend);
        return 'background: repeating-linear-gradient('+a[0].stripe_angle+'deg,' + a[0].base_color + ',' + a[0].base_color + ' 10px,' + stripe_color + ' 10px,' + stripe_color + ' 20px);';
    },
    _panelGenerator: function (a){
        var container = Ext.create('Ext.container.Container', {
            xtype: 'Viewport',
            id: 'myViewport',
            
            items: [{
                region: 'north',
                items: [{
                    xtype: 'tabpanel',
                    width: '100%',
                    collapsible: true,
                    items: [{
                        title: 'Tools',
                        width: '100%',
                        bodyStyle: a[0].panel_tools_sc + 'font-size:' + a[0].panel_font_s + 'px;padding:' + a[0].panel_paddin + 'px;',
                        cls: 'fixTabMargins',
                        tabConfig: {
                            style: {
                                background: a[0].panel_tools_tc,
                            }
                        },
                        items: [{
                            xtype: 'component',
                            html: a[0].panel_tools_tx,
                        },{
                            xtype: 'button',
                            text: 'Print Lanscape',
                            height: a[0].button_height,
                            cls: 'black_button_text_color',
                            style: {
                                background: a[0].button_print,
                                margin: '0px 10px 0px 0px',
                            },
                            listeners: {
                                afterrender: function (v) {
                                    v.el.on('click', function () {
                                        Ext.create('Export')._print('myChart',1);
                                    });
                                },
                                scope: this
                            },
                        }, {
                            xtype: 'button',
                            text: 'Print Portrait',
                            height: a[0].button_height,
                            cls: 'black_button_text_color',
                            style: {
                                background: a[0].button_print,
                                margin: '0px 10px 0px 0px',
                            },
                            listeners: {
                                afterrender: function (v) {
                                    v.el.on('click', function () {
                                        Ext.create('Export')._print('myChart',2);
                                    });
                                },
                                scope: this
                            },
                        }
                        /*
                        
                        , {
                                xtype: 'button',
                                text: 'Excel',
                                height: a[0].button_height,
                                cls: 'black_button_text_color',
                                style: {
                                    background: a[0].button_excel,
                                    margin: '0px 10px 0px 0px',
                                },
                                listeners: {
                                    afterrender: function (v) {
                                        v.el.on('click', function () {
                                            Ext.create('Export')._print('myChart');
                                        });
                                    },
                                    scope: this
                                },
                            }, {
                                xtype: 'button',
                                text: 'Adobe PDF',
                                cls: 'black_button_text_color',
                                height: a[0].button_height,
                                style: {
                                    background: a[0].button_a_pdf,
                                    margin: '0px 10px 0px 0px',
                                },
                                listeners: {
                                    afterrender: function (v) {
                                        v.el.on('click', function () {
                                            Ext.create('Export')._pdf('myChart');
                                        });
                                    },
                                    scope: this
                                }
                            }*/]
                    }, {
                        title: 'About',
                        width: '100%',
                        html: a[0].panel_about_tx,
                        bodyStyle: a[0].panel_about_sc + 'font-size:' + a[0].panel_font_s + 'px;padding:' + a[0].panel_paddin + 'px;',
                        cls: 'fixTabMargins',
                        tabConfig: {
                            style: {
                                background: a[0].panel_about_tc,
                            }
                        },
                    }, {
                        title: 'Usage',
                        width: '100%',
                        html: a[0].panel_usage_tx,
                        bodyStyle: a[0].panel_usage_sc + 'font-size:' + a[0].panel_font_s + 'px;padding:' + a[0].panel_paddin + 'px;',
                        cls: 'fixTabMargins',
                        tabConfig: {
                            style: {
                                background: a[0].panel_usage_tc,
                            }
                        },
                    }, {
                        title: 'Version',
                        width: '100%',
                        html: a[0].panel_version_tx,
                        bodyStyle: a[0].panel_version_sc + 'font-size:' + a[0].panel_font_s + 'px;padding:' + a[0].panel_paddin + 'px;',
                        cls: 'fixTabMargins',
                        tabConfig: {
                            style: {
                                background: a[0].panel_version_tc,
                            }
                        },
                    },{
                        title: 'Support',
                        width: '100%',
                        bodyStyle: a[0].panel_support_sc + 'font-size:' + a[0].panel_font_s + 'px;padding:' + a[0].panel_paddin + 'px;',
                        cls: 'fixTabMargins',
                        tabConfig: {
                            style: {
                                background: a[0].panel_support_tc,
                            }
                        },
                        items: [{
                            xtype: 'component',
                            html: a[0].panel_support_tx,
                        }, {
                            xtype: 'button',
                            text: 'Contact Support',
                            height: a[0].button_height,
                            style: {
                                background: a[0].button_support,
                                margin: '0px 10px 0px 0px',
                            },
                            listeners: {
                                afterrender: function (v) {
                                    v.el.on('click', function () {
                                        Ext.create('Emailer')._emailer();
                                    });
                                },
                                scope: this
                            },
                        }],
                    }]
                }]
            }]
        });
        return container;
    },
    _divGenerator: function (a,spacerWidth,headerBorder){
        content = '<div class="divTable"><div class="divTableBody"><div class="divTableRowHeader">';
        var spaceInsertCount = a.length - 1;
        if (a.length & 1) {
            divSpacerCount = a.length;
        } else {
            divSpacerCount = spaceInsertCount;
        }
        for (var x = 0; x < a.length; x++) {
            if (x & 1) { // Check if the number is odd or even as we want to create a zebra effect
                if (x < divSpacerCount) {
                    content += this._htmlGenerator('spacer',spacerWidth,headerBorder);
                }
            } else {
                content += this._htmlGenerator(a[x][0],spacerWidth,headerBorder);
            }
        }
        content += '</div><div class="divTableRowContent">';
        for (x = 1; x < a.length; x++) {
            if (x & 1) { // Check if the number is odd or even as we want to create a zebra effect
                content += this._htmlGenerator(a[x][0],spacerWidth,headerBorder);
            }
            if (x < divSpacerCount) {
                content += this._htmlGenerator('spacer',spacerWidth,headerBorder);
            }
        }
        content += '</div></div></div>';
        return content;
    },
    _htmlGenerator: function (a,spacerWidth,headerBorder) {
        if (a === 'spacer') {
            o = 'style="width:'+spacerWidth+'";';
            o = '<div '+o+'>&nbsp;</div>';
        } else {
            if(a.type==='header'){
                border = headerBorder;
            }else{
                border = '';
            }
            o= 'style="font_size:'+a.fontSize+';font-family:Gill Sans Extrabold, sans-serif;font-weight:'+a.fontWeight+';overflow:hidden;word-break:normal;';
            o+= 'vertical-align:top;display:table-cell;';
            o+= 'width:'+a.width+';height:'+a.height+';padding:'+a.padding+';margin:'+a.margin+';'+border+';';
            o+= 'background:'+a.background+';color:'+a.color+';"';
            o = '<div '+o+'>' + a.txt + '</div>';
            
        }
        a = undefined;
        return o;
    },
    constructor: function (config) {
        this.initConfig(config);
    },
});
Ext.define('Emailer', {
    _emailer: function () {
        var s = Ext.create('App.Information').pP_EmailSubj;
        var o = '\r\n';
        o += '\r\n';
        o += '\r\n';
        o += Ext.create('App.Information').pP_EmailBody;
        o += '\r\n';
        o += Ext.create('Telemetry')._this_Application_Details();
        o += Ext.create('Telemetry')._user_Vars();
        o += Ext.create('Telemetry')._user_Rally_Vars("a", "b", "c"); // <------- NEED THESE SCOPED
        o = encodeURIComponent(o);
        // window.top.location MUST be used for HTTPS transfer out of browser //
        window.top.location = 'mailto:' + Ext.create('App.Information').pP_EmailAddr + '?subject=' + s + '&body=' + o;
    },
});
Ext.define('Telemetry', {
    _this_Application_Details: function () {
        var o = [];
        o.push('> - - - - - - - - - - < Application Details');
        o.push('> App Name : ' + Ext.create('App.Information').pP_AppliName);
        o.push('> App Version : ' + Ext.create('App.Information').pAppVers);
        o.push('> App Version Status : ' + Ext.create('App.Information').pP_AppStatus);
        o.push('> App Designer : ' + Ext.create('App.Information').pP_AppliOwne);
        o.push('> App Description : ' + Ext.create('App.Information').pP_AppliDesc);
        o.push('> App Release Date : ' + Ext.create('App.Information').pP_AppliDate);
        return o;
    },
    _this_Application_Output: function (a) {
        var o = [];
        console.log('xxx ',a);
        o.push('> - - - - - - - - - - < Application Output');
        for (var i = 0; i < a.length; i++) {
            o.push('> FormattedID : ' + a[i].raw.FormattedID + ' Name : ' + a[i].raw.Name + ' _Ref : ' + a[i].raw._ref);
        }
        a = undefined;
        return Ext.create('Tools')._common_Array_Outputter(o);
    },
    _user_Vars: function () {
        var o = [];
        o.push('> - - - - - - - - - - < Local Details');
        o.push('> Browser Web App Name : ' + navigator.appName);
        o.push('> Browser User Agent : ' + navigator.userAgent);
        o.push('> Browser Version : ' + navigator.appVersion);
        o.push('> Browser Code Name : ' + navigator.appCodeName);
        o.push('> Platform : ' + navigator.platform);
        o.push('> OS CPU : ' + navigator.oscpu);
        o.push('> Cookies : ' + navigator.cookieEnabled);
        o.push('> Outer Width : ' + window.outerWidth);
        o.push('> Outer Height : ' + window.outerHeight);
        o.push('> Inner Width : ' + window.innerWidth);
        o.push('> Inner Height : ' + window.innerHeight);
        o.push('> Base URI : ' + document.getElementsByTagName('script')[0].baseURI);
        o.push('> SRC : ' + document.getElementsByTagName('script')[0].src);
        o.push('> LocalName : ' + document.getElementsByTagName('script')[0].localName);
        o.push('> Type : ' + document.getElementsByTagName('script')[0].type);
        return Ext.create('Tools')._common_Array_Outputter(o);
    },
    _user_Rally_Vars: function (context_User, context_Project, context_Workspace) {
        var o = [];
        o.push('> - - - - - - - - - - < User Details');
        o.push('> AC User Username : ' + 'test');//context_User.UserName);
        o.push('> AC User Name : ' + 'test');// context_User._refObjectName);
        o.push('> AC User Role : ' + 'test');// context_User.Role);
        o.push('> AC Application Launched From Node : ' + 'test');// context_Project._refObjectName);
        o.push('> AC Application Workspace Name : ' + 'test');// context_Workspace._refObjectName);
        o.push('> AC Application Workspace Date/Time Format : ' + 'test');// context_Workspace.WorkspaceConfiguration.DateFormat);
        return Ext.create('Tools')._common_Array_Outputter(o);
    }
});
Ext.define('Tools', {
    _shadeBlendConvert: function (color, percent) {
        var R = parseInt(color.substring(1, 3), 16);
        var G = parseInt(color.substring(3, 5), 16);
        var B = parseInt(color.substring(5, 7), 16);
        R = parseInt(R * (100 + percent) / 100);
        G = parseInt(G * (100 + percent) / 100);
        B = parseInt(B * (100 + percent) / 100);
        R = (R < 255) ? R : 255;
        G = (G < 255) ? G : 255;
        B = (B < 255) ? B : 255;
        var RR = ((R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16));
        var GG = ((G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16));
        var BB = ((B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16));
        return "#" + RR + GG + BB;
    },
    _common_Array_Outputter: function (a) {
        var r = '\r\n';
        var l = a.length;
        var o = '';
        var p = String(l).length;
        for (var x = 0; x < l; x++) {
            o += '[#' + this._number_Pad(x, p) + '] ' + a[x] + r;
        }        
        a = undefined;
        return o;
    },
    _number_Pad: function (num, size) {
        return Array(Math.max(size - String(num).length + 1, 0)).join(0) + num;
    }
});
Ext.define('Export', {
    _print: function (myChart,ori) {
        var mywindow = window.open('', 'Printing '+Ext.create('App.Information').pP_AppliName, 'height=800,width=1000');
        if(ori===1){
        console.log(ori);
            printCss = '<style type="text/css" media="print">@page { size: landscape; }</style>';
        }
        if(ori===2){
        console.log(ori);
            printCss = '<style type="text/css"></style>';
        }
        console.log('css ',printCss);
        mywindow.document.write('<html><head><title>Printing '+Ext.create('App.Information').pP_AppliName+'</title>');
        mywindow.document.write(printCss);
        mywindow.document.write('</head><body >');
        mywindow.document.write(document.getElementById(myChart).innerHTML);
        mywindow.document.write('</body></html>');
        mywindow.document.close(); // necessary for IE >= 10
        mywindow.focus(); // necessary for IE >= 10*/
        mywindow.print();
        mywindow.close();
        return true;
    },
    _pdf: function (id, test) {
        test = 'test';
        id = 'myViewport';
    var canvasElement = document.getElementById(id);

    var MIME_TYPE = "image/png";

    var imgURL = canvasElement.toDataURL(MIME_TYPE);

    var dlLink = document.createElement('a');
    dlLink.download = fileName;
    dlLink.href = imgURL;
    dlLink.dataset.downloadurl = [MIME_TYPE, dlLink.download, dlLink.href].join(':');

    document.body.appendChild(dlLink);
    dlLink.click();
    document.body.removeChild(dlLink);
    }
});
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownSettings", {
        requires: [
            "Rally.apps.charts.settings.ChartDisplayTypePicker",
            "Rally.apps.charts.settings.DataTypePicker",
            "Rally.apps.charts.settings.TimeboxPicker",
            "Rally.ui.CheckboxField"
        ],

        config: {
            app: undefined
        },
        
        constructor: function (config) {
            this.mergeConfig(config);
        },

        _buildSettingsComponent: function (type, label, name) {
            console.log(type,label,name);
            var self = this;

            var componentAdded = function (cmp) {
                this.settingsParent = this.settingsParent || self;
            };

            var settings = {
                xtype: type,
                label: label,
                listeners: {
                    added: componentAdded
                }
            };
            if (name) {
                settings.name = name;
                settings.cls = "settings-" + name;
            }
            return settings;
        },

        _isOnScopedDashboard: function() {
            return this.app.isOnScopedDashboard() && !!this.app.context.getTimeboxScope();
        },

        getFields: function() {
            var dataTypePicker = this._buildSettingsComponent("chartdatatypepicker", "Data Type"),
                displayPicker = this._buildSettingsComponent("chartdisplaytypepicker", "Chart Type"),
                timeboxPicker = this._buildSettingsComponent("charttimeboxpicker", "Level"),
                labelNameVisible = this._buildSettingsComponent("rallycheckboxfield", "Show Iteration Labels", 'showLabels');
            
            if(this._isOnScopedDashboard()) {
                return [dataTypePicker, displayPicker, labelNameVisible];
            } else {
                return [timeboxPicker, dataTypePicker, displayPicker, labelNameVisible];
            }
        }
        

    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownChart", {
        requires: [
            "Rally.ui.chart.Chart"
        ],

        defaultChartComponentConfig: function () {
            return {
                xtype: "rallychart",
                itemId: "burndownchart",
                animate: true,
                aggregationErrorMessage: "No data to display. Check the data type setting for displaying data based on count versus plan estimate.",

                storeType: "Rally.data.lookback.SnapshotStore",
                storeConfig: {
                    find: {
                        "_TypeHierarchy": {
                            '$in': [-51038, -51006]
                        },
                        "Children": null
                    },
                    fetch: ["ScheduleState", "PlanEstimate", "ObjectId", "_ValidFrom", "_ValidTo"],
                    hydrate: ["ScheduleState"],
                    sort: {
                        "_ValidFrom": 1
                    },
                    compress: true,
                    useHttpPost: true
                },

                calculatorType: "Rally.apps.charts.burndown.BurnDownCalculator",
                calculatorConfig: {
                    timeZone: "GMT",
                    completedScheduleStateNames: null, // defaults hide problems
                    enableProjections: true

                    //chartAggregationType: ''
                },
                chartColors: ["#7cc6f4", "#dee255", "#666666", "#c0c0c0"],
                cls: 'myCustom',
                id: 'myChart',
                overCls: 'myOver',
                chartConfig: {
                    chart: {
                        zoomType: "xy",
                        backgroundColor: '#ebe7e4',
                        type: 'area',
                        grid: true,
                    },
                    xAxis: {
                        categories: [],
                        tickmarkPlacement: "on",
                        tickInterval: 7,
                        title: {
                            text: "Days",
                            margin: 12
                        },
                        maxPadding: 0.25,
                        labels: {
                            x: 0,
                            y: 20,
                            overflow: "justify"
                        }
                    },

                    yAxis: [{
                        plotOptions: {
                            series: {
                                threshold: 0,
                            }
                        },
                    }],
                    tooltip: {
                        formatter: function () {
                            var floatValue = parseFloat(this.y),
                                value = this.y;

                            if (!isNaN(floatValue)) {
                                value = Math.floor(floatValue * 100) / 100;
                            }

                            return "" + this.x + "<br />" + this.series.name + ": " + value;
                        }
                    },
                    plotOptions: {
                        series: {
                            marker: {
                                enabled: true,
                                symbol: 'circle',
                                radius: 3,
                                states: {
                                    hover: {
                                        enabled: true
                                    }
                                }
                            },
                            area: {
                                stacking: 'normal'
                            },
                            connectNulls: true
                        },
                        column: {
                            pointPadding: 0,
                            borderWidth: 0,
                            stacking: null,
                            shadow: false
                        }
                    }
                }
            };

        }
    });
}());
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.charts.burndown.BurnDownApp', {
        extend: 'Rally.app.TimeboxScopedApp',

        settingsScope: 'workspace',

        requires: [
            'Rally.apps.charts.burndown.BurnDownSettings',
            'Rally.data.wsapi.Store',
            'Rally.util.Help',
            'Rally.ui.combobox.IterationComboBox',
            'Rally.ui.combobox.ReleaseComboBox',
            'Rally.apps.charts.IntegrationHeaders',
            'Rally.apps.charts.burndown.BurnDownChart'
        ],
        mixins: [
            'Rally.apps.charts.DateMixin'
        ],

        cls: 'burndown-app',

        items: [{
            xtype: 'container',
            itemId: 'header',
            cls: 'header'
        }],


        scopeObject: undefined,

        customScheduleStates: true, // defaults hide problems

        config: {
            defaultSettings: {
                showLabels: true,
                chartAggregationType: undefined,
                chartDisplayType: undefined,
                chartTimebox: undefined,
                title: ''
            }
        },

        chartComponentConfig: undefined,

        getSettingsFields: function () {
            this.chartSettings = this.chartSettings || Ext.create('Rally.apps.charts.burndown.BurnDownSettings', {
                app: this
            });

            return this.chartSettings.getFields();
        },

        onScopeChange: function (scope) {
            if (!this.ignoreOnScopeChange) {
                this._rebuildChartForScope(scope.getRecord().get('_ref'));
            }
        },
        launch: function () {

            this._buildLayout();
            if (this._settingsInvalid()) {
                this.fireEvent('settingsneeded', this);
                return;
            }
            this.customScheduleStates = null;
            this.chartComponentConfig = Ext.create('Rally.apps.charts.burndown.BurnDownChart', this).defaultChartComponentConfig();
            Ext.create('Rally.apps.charts.IntegrationHeaders', this).applyTo(this.chartComponentConfig.storeConfig);
            console.log(this,'xxx');
            this._addHelpComponent();
            this._loadUserStoryModel();
            this._saveScopeType();
            this.callParent(arguments);
            if (!this.isOnScopedDashboard()) {
                this.ignoreOnScopeChange = true;
                this._getScopePicker().on('ready', this._loadScopePreference, this, {
                    single: true
                });
            }
        },
        _buildLayout: function () {
            this.add(Ext.create('App.Information')._generate_Tabs());
        },
        _addHelpComponent: function () {
            //this.down('#header').add(this._buildHelpComponent());
        },
        _buildHelpComponent: function () {
            return Ext.create('Ext.Component', {
                renderTpl: Rally.util.Help.getIcon({
                    cls: Rally.util.Test.toBrowserTestCssClass(this.help.cls),
                    id: this.help.id
                })
            });
        },

        _rebuildChartForScope: function (scopeRef) {
            this._destroyChart();

            this._saveScopePreference(scopeRef);
            this._loadScopeObject(scopeRef);
        },

        _destroyChart: function () {
            this.remove('burndownchart');
        },

        _saveScopePreference: function (scopeRef) {
            if (!this.isOnScopedDashboard()) {
                var settings = {};
                settings[this._getScopeType()] = scopeRef;

                Rally.data.PreferenceManager.update({
                    appID: this.getContext().get('appID'),
                    settings: settings,
                    scope: this
                });
            }
        },

        _loadScopePreference: function (picker) {
            Rally.data.PreferenceManager.load({
                appID: this.getContext().get('appID'),
                success: function (preferences) {
                    var scopeRef = preferences[this._getScopeType()];
                    if (!scopeRef || scopeRef === 'undefined') {
                        var pickerRecord = picker.getRecord();
                        if (pickerRecord) {
                            scopeRef = pickerRecord.get('_ref');
                            this._saveScopePreference(scopeRef);
                        }
                    }
                    this.ignoreOnScopeChange = false;

                    if (scopeRef && scopeRef !== 'undefined') {
                        this._setScopeValue(scopeRef);
                        scopeRef = this._getScopePicker().getValue();
                        if (scopeRef) {
                            this._rebuildChartForScope(scopeRef);
                        }
                    }
                },
                scope: this
            });
        },

        _setScopeValue: function (scopeRef) {
            this._getScopePicker().setValue(scopeRef);
        },

        _loadTimeboxes: function () {
            Ext.create('Rally.data.wsapi.Store', {
                model: this.scopeObject._type,
                filters: [{
                        property: 'Name',
                        operator: '=',
                        value: this.scopeObject.Name
                    },
                    {
                        property: this._getScopeObjectStartDateName(),
                        operator: '=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                    },
                    {
                        property: this._getScopeObjectEndDateName(),
                        operator: '=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                    }
                ],
                context: this.getContext().getDataContext(),
                fetch: ['ObjectID'],
                limit: Infinity,
                autoLoad: true,
                listeners: {
                    load: function (store, records) {
                        this._getTimeboxesInScope(store, records);
                    },
                    scope: this
                }
            });
        },

        _onScopeObjectLoaded: function (record) {
            this._setScopeFromData(record);

            this._updateChartTitle();
            this._updateYAxis();

            this._addDateBounds();
            this._addAggregationTypeToCalculator();
            this._loadTimeboxes();
        },

        _renderChartBasedOnType: function () {
            if (this._getScopeType() === 'release') {
                this._fetchIterations();
            } else {
                if (this.customScheduleStates === null) { // wait until we get the schedule states
                    this.deferredAddChart = this._addChart;
                } else {
                    this._addChart();
                }
            }
        },

        _setScopeFromData: function (record) {
            this.scopeObject = record.data;
        },

        _getTimeboxesInScope: function (store, records) {
            var storeConfig = this.chartComponentConfig.storeConfig;
            var type = Ext.String.capitalize(this._getScopeType());
            var oids = [];
            var i;

            this.timeboxes = store.getItems();
            this._clearStoreConfig(storeConfig);

            for (i = 0; i < this.timeboxes.length; i++) {
                oids.push(this.timeboxes[i].ObjectID);
            }
            storeConfig.find[type] = {
                '$in': oids
            };

            this._renderChartBasedOnType();

        },

        _addChartWithIterationLines: function () {
            this._addChart();
            console.log('here');
            this.down('rallychart').on('snapshotsAggregated', this._addIterationLines, this);
        },

        _onIterationsLoaded: function (store) {
            this.iterations = store.getItems();

            if (this.customScheduleStates === null) {
                this.deferredAddChart = this._addChartWithIterationLines;
            } else {
                this._addChartWithIterationLines();
            }
        },

        _addDateBounds: function () {
            this._addDateBoundsToQuery();
            this._addDateBoundsToCalculator();
        },

        _addDateBoundsToQuery: function () {

        },

        _getNow: function () {
            return new Date();
        },

        _addDateBoundsToCalculator: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            var endDate = this._getScopeObjectEndDate();
            var now = this._getNow();
            calcConfig.startDate = Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true);
            if (now > this._getScopeObjectStartDate() && now < this._getScopeObjectEndDate()) {
                endDate = now;
            }
            calcConfig.endDate = Rally.util.DateTime.toIsoString(endDate, true);
            // S53625: If the time-box has ended, disable the projection line
            if (now > this._getScopeObjectEndDate()) {
                calcConfig.enableProjections = false;
            } else {
                calcConfig.enableProjections = true;
            }
            // add scopeEndDate, which may or may not be the same as endDate
            calcConfig.scopeEndDate = this._getScopeObjectEndDate();
        },

        _addAggregationTypeToCalculator: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            calcConfig.chartAggregationType = this.getSetting('chartAggregationType');
        },

        _updateCompletedScheduleStates: function () {
            var calcConfig = this.chartComponentConfig.calculatorConfig;
            calcConfig.completedScheduleStateNames = this.customScheduleStates;
        },

        _loadScopeObject: function (scopeRef) {
            Rally.data.ModelFactory.getModel({
                type: this._getScopeType(),

                context: {
                    workspace: this.getContext().getWorkspaceRef(),
                    project: null
                },
                success: function (model) {
                    model.load(Rally.util.Ref.getOidFromRef(scopeRef), {
                        success: function (record) {
                            this._onScopeObjectLoaded(record);
                        },
                        scope: this
                    });
                },
                scope: this
            });
        },

        _fetchIterations: function () {
            var store = Ext.create('Rally.data.wsapi.Store', {
                model: Ext.identityFn('Iteration'),
                filters: [{
                        property: 'StartDate',
                        operator: '>=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectStartDate(), true)
                    },
                    {
                        property: 'EndDate',
                        operator: '<=',
                        value: Rally.util.DateTime.toIsoString(this._getScopeObjectEndDate(), true)
                    }
                ],
                context: {
                    workspace: this.getContext().getWorkspaceRef(),
                    project: this.getContext().getProjectRef()
                },
                fetch: ['Name', 'StartDate', 'EndDate'],
                limit: Infinity
            });

            store.on('load', this._onIterationsLoaded, this);
            store.load();
        },

        _areIterationsEqual: function (iteration1, iteration2) {
            return iteration1.Name === iteration2.Name &&
                iteration1.StartDate === iteration2.StartDate &&
                iteration1.EndDate === iteration2.EndDate;
        },

        _addIterationLines: function (chart) {
            var axis = chart.chartConfig.xAxis;
            var categories = chart.chartData.categories;
            var i, j;
            var uniqueIterations = [];
            var unique;

            axis.plotLines = [];
            axis.plotBands = [];

            for (i = 0; i < this.iterations.length; i++) {
                unique = true;
                for (j = 0; j < uniqueIterations.length; j++) {
                    if (this._areIterationsEqual(uniqueIterations[j], this.iterations[i])) {
                        unique = false;
                        break;
                    }
                }
                if (unique === true) {
                    uniqueIterations.push(this.iterations[i]);
                }
            }

            for (i = 0; i < uniqueIterations.length; i++) {
                axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[i], false));
                axis.plotBands.push(this._getPlotBand(categories, uniqueIterations[i], i % 2 !== 0));
            }

            if (uniqueIterations.length > 0) {
                axis.plotLines.push(this._getPlotLine(categories, uniqueIterations[uniqueIterations.length - 1], true));
            }
        },
        _buildLabelText: function (iteration) {
            var labelSetting = this.getSetting("showLabels");

            var text = '';
            if (labelSetting) {
                text = iteration.Name || '';
            }
            return text;
        },

        _getPlotBand: function (categories, iteration, shouldColorize) {
            var startDate = this.dateStringToObject(iteration.StartDate);
            var endDate = this.dateStringToObject(iteration.EndDate);

            var label = {
                text: this._buildLabelText(iteration),
                align: 'center',
                rotation: 0,
                y: -7
            };

            return {
                color: shouldColorize ? '#F2FAFF' : '#FFFFFF',
                from: this._getNearestWorkday(categories, startDate),
                to: this._getNearestWorkday(categories, endDate),

                label: label
            };
        },

        _getNearestWorkday: function (categories, date) {
            var dateStr = Ext.Date.format(date, 'Y-m-d');
            var index = categories.indexOf(dateStr);
            if (index === -1) {
                var workdays = this._getWorkspaceConfiguredWorkdays();
                if (workdays.length < 1) {
                    return -1;
                }
                // date not in categories (probably) means it falls on a non-workday...back up to the next previous workday
                while (workdays.indexOf(Ext.Date.format(date, 'l')) === -1 && date > this._getScopeObjectStartDate()) {
                    date = Ext.Date.add(date, Ext.Date.DAY, -1);
                    dateStr = Ext.Date.format(date, 'Y-m-d');
                    index = categories.indexOf(dateStr);
                }
            }
            return index;
        },

        _getPlotLine: function (categories, iteration, lastLine) {
            var dateObj;
            var dateIndex;

            if (lastLine) {
                dateObj = this.dateStringToObject(iteration.EndDate);
            } else {
                dateObj = this.dateStringToObject(iteration.StartDate);
            }

            dateIndex = this._getNearestWorkday(categories, dateObj);

            return {
                color: '#BBBBBB',
                dashStyle: 'ShortDash',
                width: 2,
                zIndex: 3,
                value: dateIndex
            };
        },

        _addChart: function () {
            this._updateCompletedScheduleStates();
            this._updateChartConfigDateFormat();
            this._updateChartConfigWorkdays();
            var chartComponentConfig = Ext.Object.merge({}, this.chartComponentConfig);

            this.add(chartComponentConfig);
            this.down('rallychart').on('snapshotsAggregated', this._onSnapshotDataReady, this);
        },



        _onSnapshotDataReady: function (chart) {
            this._updateDisplayType(chart);
            this._updateXAxis(chart);
        },

        _updateDisplayType: function (chart) {
            var series = chart.chartData.series;
            var displayType = this.getSetting('chartDisplayType');
            var i;

            for (i = 0; i < series.length; i++) {
                if (this._seriesFollowsDisplayType(series[i])) {
                    series[i].type = displayType;
                }
            }
        },

        _seriesFollowsDisplayType: function (series) {
            return series.name.indexOf('Ideal') === -1 && series.name.indexOf('Prediction') === -1;
        },

        _updateYAxis: function () {
            this._updateYAxisTitle();
            this._updateYAxisConfig();
        },

        _updateYAxisTitle: function () {
            var chartConfig = this.chartComponentConfig.chartConfig;
            chartConfig.yAxis = [{}];
            chartConfig.yAxis[0].title = {
                text: this._getAxisTitleBasedOnAggregationType()
            };
        },

        _updateYAxisConfig: function () {
            var axis = this.chartComponentConfig.chartConfig.yAxis[0];
            axis.min = 0;
            axis.labels = {
                x: -5,
                y: 4
            };
        },

        _updateXAxis: function (chart) {
            if (this.container.dom.offsetWidth < 1000) {
                chart.chartConfig.xAxis.labels.staggerLines = 2;
            }
            chart.chartConfig.xAxis.labels.step = Math.round(chart.chartData.categories.length / 100);
            chart.chartConfig.xAxis.tickInterval = this._configureChartTicks(chart.chartData.categories.length);
        },

        _configureChartTicks: function (days) {
            var pixelTickWidth = 125,
                appWidth = this.getWidth(),
                ticks = Math.floor(appWidth / pixelTickWidth);

            return Math.ceil(days / ticks);
        },

        _getAxisTitleBasedOnAggregationType: function () {
            var aggregationType = this.getSetting('chartAggregationType');
            if (aggregationType === 'storycount') {
                return 'Count';
            } else {
                return 'Plan Estimate';
            }
        },

        _updateChartConfigDateFormat: function () {
            var self = this;

            this.chartComponentConfig.chartConfig.xAxis.labels.formatter = function () {
                return self._formatDate(self.dateStringToObject(this.value));
            };
        },

        _updateChartConfigWorkdays: function () {
            this.chartComponentConfig.calculatorConfig.workDays = this._getWorkspaceConfiguredWorkdays().split(',');
        },

        _parseRallyDateFormatToHighchartsDateFormat: function () {
            var dateFormat = this._getUserConfiguredDateFormat() || this._getWorkspaceConfiguredDateFormat();

            for (var i = 0; i < this.dateFormatters.length; i++) {
                dateFormat = dateFormat.replace(this.dateFormatters[i].key, this.dateFormatters[i].value);
            }

            return dateFormat;
        },

        _formatDate: function (date) {
            if (!this.dateFormat) {
                this.dateFormat = this._parseRallyDateFormatToHighchartsDateFormat();
            }

            return Highcharts.dateFormat(this.dateFormat, date.getTime());
        },

        _getUserConfiguredDateFormat: function () {
            return this.getContext().getUser().UserProfile.DateFormat;
        },

        _getWorkspaceConfiguredDateFormat: function () {
            return this.getContext().getWorkspace().WorkspaceConfiguration.DateFormat;
        },

        _getWorkspaceConfiguredWorkdays: function () {
            return this.getContext().getWorkspace().WorkspaceConfiguration.WorkDays;
        },

        _updateChartTitle: function () {
            this.chartComponentConfig.chartConfig.title = this._buildChartTitle();
        },

        _buildChartTitle: function () {
            var widthPerCharacter = 10;
            var totalCharacters = Math.floor(this.getWidth() / widthPerCharacter);
            var title = this._getDefaultTitle();
            var align = 'center';

            if (this.scopeObject) {
                title = this.scopeObject.Name;
            }

            if (totalCharacters < title.length) {
                title = title.substring(0, totalCharacters) + '...';
                align = 'left';
            }

            return {
                text: title + ' Burn Delta',
                align: align,
                margin: 30
            };
        },

        _getDefaultTitle: function () {
            return Ext.String.capitalize(this._getScopeType());
        },

        _settingsInvalid: function () {
            var chartAggregationType = this.getSetting('chartAggregationType'),
                chartDisplayType = this.getSetting('chartDisplayType'),
                chartTimebox = this.getSetting('chartTimebox');

            var invalid = function (value) {
                return !value || value === 'undefined';
            };

            return invalid(chartAggregationType) || invalid(chartDisplayType) ||
                this._chartTimeboxInvalid(chartTimebox);
        },

        _chartTimeboxInvalid: function (chartTimebox) {
            if (this.context.getTimeboxScope()) {
                return false;
            }

            return !chartTimebox || chartTimebox === 'undefined';
        },

        _saveScopeType: function () {
            this.scopeType = this._getScopeType();
        },

        _getScopeType: function () {
            if (this.isOnScopedDashboard()) {
                return this._getDashboardScopeType();
            } else {
                return this._getSavedScopeType();
            }
        },

        _getDashboardScopeType: function () {
            return this.getContext().getTimeboxScope().getType();
        },

        _getSavedScopeType: function () {
            return this.getSetting('chartTimebox');
        },

        _getScopePicker: function () {
            if (this.isOnScopedDashboard()) {
                return this.getContext().getTimeboxScope();
            } else {
                return this.down('rally' + this._getScopeType() + 'combobox');
            }
        },

        _getScopeObjectStartDateName: function () {
            if (!this.scopeObject) {
                return '';
            } else if (this.scopeObject._type === 'release') {
                return 'ReleaseStartDate';
            } else {
                return 'StartDate';
            }
        },

        _getScopeObjectEndDateName: function () {
            if (!this.scopeObject) {
                return '';
            } else if (this.scopeObject._type === 'release') {
                return 'ReleaseDate';
            } else {
                return 'EndDate';
            }
        },

        _getScopeObjectStartDate: function () {
            if (!this.scopeObject) {
                return this._getNow();
            } else if (this.scopeObject._type === 'release') {
                return this.scopeObject.ReleaseStartDate;
            } else {
                return this.scopeObject.StartDate;
            }
        },

        _getScopeObjectEndDate: function () {
            if (!this.scopeObject) {
                return this._getNow();
            } else if (this.scopeObject._type === 'release') {
                return this.scopeObject.ReleaseDate;
            } else {
                return this.scopeObject.EndDate;
            }
        },

        _clearStoreConfig: function (storeConfig) {
            if (storeConfig.find.hasOwnProperty('Release')) {
                delete storeConfig.find.Release;
            }

            if (storeConfig.find.hasOwnProperty('Iteration')) {
                delete storeConfig.find.Iteration;
            }
        },

        _loadUserStoryModel: function () {
            Rally.data.ModelFactory.getModel({
                type: "UserStory",
                context: this._getContext(),
                success: function (model) {
                    this._getScheduleStateValues(model);
                },
                scope: this
            });
        },

        _getContext: function () {
            return {
                workspace: this.context.getWorkspaceRef(),
                project: null
            };
        },

        _getScheduleStateValues: function (model) {
            var scheduleStates = model.getField('ScheduleState').getAllowedStringValues();

            this.customScheduleStates = scheduleStates.slice(scheduleStates.indexOf('Accepted'), scheduleStates.length);

            if (this.deferredAddChart) {
                this.deferredAddChart.call(this);
            }
        }
    });
}());
                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define("Rally.apps.charts.burndown.BurnDownCalculator", {
        extend: "Rally.data.lookback.calculator.TimeSeriesCalculator",
        mixins: [
            "Rally.apps.charts.DateMixin"
        ],

        getDerivedFieldsOnInput: function () {
            var completedStates = this.config.completedScheduleStateNames,
                aggregationType = this.config.chartAggregationType;

            return [
                {
                    "as": "RemainingPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if(completedStates.indexOf(ss) < 0) {
                            if(aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                },
                {
                    "as": "AcceptedPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if (completedStates.indexOf(ss) > -1) {
                            if (aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                },
                {
                    "as": "CompletedPoints",
                    "f": function (snapshot) {
                        var ss = snapshot.ScheduleState;
                        if (completedStates.indexOf(ss) > -1) {
                            if (aggregationType === "storycount") {
                                return 1;
                            } else if (snapshot.PlanEstimate) {
                                return snapshot.PlanEstimate;
                            }
                        }

                        return 0;
                    }
                }
            ];
        },

        getMetrics: function () {
            return [
                {
                    "field": "RemainingPoints",
                    "as": "To Do",
                    "f": "sum"
                },
                {
                    "field": "AcceptedPoints",
                    "as": "Accepted",
                    "f": "sum"
                }
            ];
        },

        getSummaryMetricsConfig: function () {
            return [
                {
                    'as': 'Scope_max',
                    'f': function(seriesData) {
                            var max = 0, i = 0;
                            for (i=0;i<seriesData.length;i++) {
                                if(seriesData[i].Completed + seriesData[i]['To Do'] > max) {
                                    max = seriesData[i].Completed + seriesData[i]['To Do'];
                                }
                            }
                            return max;
                         }
                }
            ];
        },

        getDerivedFieldsAfterSummary: function () {
            return  [
                {
                    "as": "Ideal",
                    "f": function (row, index, summaryMetrics, seriesData) {
                        var max = summaryMetrics.Scope_max,
                            increments = seriesData.length - 1,
                            incrementAmount;
                        if(increments === 0) {
                            return max;
                        }
                        incrementAmount = max / increments;
                        return Math.floor(100 * (max - index * incrementAmount)) / 100;
                    },
                    "display": "line",
                    "dashStyle": "Dash"
                },
                {
                    "as": "Prediction",
                    "f": function (row, index, summaryMetrics, seriesData) {
                        return null;
                    },
                    "display": "line",
                    "dashStyle": "Dash"
                }
            ];
        },

        getProjectionsConfig: function () {
            var days = (this.scopeEndDate.getTime() -
                Rally.util.DateTime.fromIsoString(this.startDate).getTime()) / (24*1000*60*60);
            var doubleTimeboxEnd = Ext.Date.add(Rally.util.DateTime.fromIsoString(this.startDate), Ext.Date.DAY, (Math.floor(days) * 2) - 1);
            var timeboxEnd = Ext.Date.add(this.scopeEndDate, Ext.Date.DAY, -1);
            if(this.projectionsConfig === undefined) {
                this.projectionsConfig = {
                    doubleTimeboxEnd: doubleTimeboxEnd,
                    timeboxEnd: timeboxEnd,

                    series: [
                        {
                            "as": "Prediction",
                            "field": "To Do"
                        }
                    ],
                    continueWhile: function (point) {
                        var dt = Rally.util.DateTime.fromIsoString(point.tick);
                        var end = (this.series[0].slope >= 0) ? this.timeboxEnd : this.doubleTimeboxEnd;
                        return point.Prediction > 0 && dt < end;
                    }
                };
            }
            return this.projectionsConfig;
        },

        _firstNonZero: function(data) {
             var i;
             for(i=0;i<data.length;i++) {
                if(data[i] > 0) {
                    return i;
                }
             }
             return 0;
        },

        _leastSquares: function(todoValues, firstIndex, lastIndex) {
            var n = (lastIndex + 1) - firstIndex;
            var i;
            var sumx = 0.0, sumx2 = 0.0, sumy = 0.0, sumy2 = 0.0, sumxy = 0.0;
            var slope, yintercept;

            //Compute sums of x, x^2, y, y^2, and xy
            for (i = firstIndex; i <= lastIndex; i++) {
                sumx  = sumx  + i;
                sumx2 = sumx2 + i * i;
                sumy  = sumy  + todoValues[i];
                sumy2 = sumy2 + todoValues[i] * todoValues[i];
                sumxy = sumxy + i * todoValues[i];
            }
            slope = (n * sumxy - sumx * sumy) / (n * sumx2 - sumx * sumx);
            yintercept = (sumy * sumx2 - sumx * sumxy) / (n * sumx2 - sumx * sumx);

            return {slope: slope, yintercept: yintercept};
        },

        runCalculation: function (snapshots) {
            var chartData = this.callParent(arguments);

            if(chartData && chartData.projections && chartData.projections.series[0].slope > 0) {
            // if the slope is positive, try using least squares.  If that's also positive, then use the first result
                var todoData = chartData.series[0].data;
                var firstTodoIndex = this._firstNonZero(todoData),
                    lastTodoIndex = (todoData.length - 1) - chartData.projections.pointsAddedCount;

                var results = this._leastSquares(todoData, firstTodoIndex, lastTodoIndex);

                // override the prediction line only if least squares says the slope isn't positive
                if(results.slope <= 0) {
                    this.projectionsConfig.series[0].slope = results.slope;

                    chartData = this.callParent(arguments);

                    // project the plot back to the first todo value
                    chartData.series[3].data[firstTodoIndex] = ((results.slope * firstTodoIndex) + results.yintercept) + (chartData.series[3].data[lastTodoIndex] - ((results.slope * lastTodoIndex) + results.yintercept));
                    chartData.series[3].connectNulls = true;
                    this.projectionsConfig = undefined;
                } else {
                // DE18732, if the slope is up, truncate it at 1.25 of the max Ideal
                    var predictionCeiling = 1.25 * chartData.series[2].data[0];
                    if (_.max(chartData.series[3].data) > predictionCeiling) {
                        var i;
                        var maxVal = predictionCeiling;
                        for(i=0;i < chartData.series[3].data.length;i++) {
                            if(chartData.series[3].data[i] > predictionCeiling) {
                                chartData.series[3].data[i] = maxVal;
                                maxVal = null;
                            }
                        }
                    }
                }

            }

            if(new Date() < this.scopeEndDate) {
                this._recomputeIdeal(chartData, this.scopeEndDate);
            }

            return chartData;
        },

        _recomputeIdeal: function(chartData, endDate) {
             var index;
             if(chartData.categories.length < 1) {
                return;
             }
             if(this.workDays.length < 1) {
                return;
             }

             var lastDate = Ext.Date.parse(chartData.categories[chartData.categories.length - 1], 'Y-m-d');
             if(endDate > lastDate) {
                // the scopeEndDate date wasn't found in the current categories...we need to extend categories to include it
                // (honoring "workDays").

                index = chartData.categories.length;
                var dt = Ext.Date.add(lastDate, Ext.Date.DAY, 1);
                while (dt < endDate) {
                    while (this.workDays.indexOf(Ext.Date.format(dt, 'l')) === -1) {
                        dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                    }
                    if (dt < endDate) {
                        chartData.categories[index++] = Ext.Date.format(dt, 'Y-m-d');
                    }
                    dt = Ext.Date.add(dt, Ext.Date.DAY, 1);
                }
                index = chartData.categories.length - 1;
             } else {
                 // it is in "scope"...set index to the index of the last workday in scope
                 index = this._indexOfDate(chartData, endDate);
                 if(index === -1) {
                    // it's in "scope", but falls on a non-workday...back up to the previous workday
                    while (this.workDays.indexOf(Ext.Date.format(endDate, 'l')) === -1) {
                        endDate = Ext.Date.add(endDate, Ext.Date.DAY, -1);
                        index = this._indexOfDate(chartData, endDate);
                    }
                 }
             }
             if(index < 0) {
                return;
             }
             // set first and last point, and let connectNulls fill in the rest
             var i;
             var seriesData = chartData.series[2].data;
             for (i=1;i<index;i++) {
                seriesData[i] = null;
             }
             seriesData[index] = 0;
        },

        _indexOfDate: function(chartData, date) {
             var dateStr = Ext.Date.format(date, 'Y-m-d');
             return chartData.categories.indexOf(dateStr);
        },

        _removeFutureSeries: function (chartData, seriesIndex, dayIndex) {
            if(chartData.series[seriesIndex].data.length > dayIndex) {
                while(++dayIndex < chartData.series[seriesIndex].data.length) {
                    chartData.series[seriesIndex].data[dayIndex] = null;
                }
            }
        },

        _projectionsSlopePositive: function (chartData) {
            if(chartData.projections && chartData.projections.series) {
                return chartData.projections.series[0].slope >= 0;
            }

            return true;
        }
    });
}());

                (function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Rally.apps.charts.burndown.ReleaseBurnDownApp', {
        extend: 'Rally.apps.charts.burndown.BurnDownApp',
        help: {
            id: 278
        },
        integrationHeaders : {
            name: 'Release Burndown'
        }
    });
}());


            Rally.launchApp('Rally.apps.charts.burndown.ReleaseBurnDownApp', {
                name:"Burndown",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .burndown-app .chartControls,
.app-settings .settings-form .paddedSettingCmp {
  margin: 15px;
  border: 0px;
}
.burndown-app .chartControls .rui-triggerfield {
  display: inline-block;
}
.burndown-app .chartControls label {
  display: inline-block;
  font-size: 1.2em;
  margin: 3px 8px;
}
.portfolio-cfd-app,
.portfolio-burnup-app,
.burndown-app {
  margin: 10px;
  padding-right: 20px;
  background-color: transparent;
}
.portfolio-cfd-app .rally-help-icon,
.burndown-app .rally-help-icon,
.portfolio-burnup-app .rally-help-icon,
.chart-app .rally-help-icon {
  float: right;
}
.portfolio-cfd-app .chart,
.portfolio-burnup-app .chart {
  min-height: 2em;
}
.app-settings .settings-form .piButton {
  padding: 5px 15px 7px 15px;
  z-index: 101;
  margin-bottom: 10px;
}
.app-settings .settings-form .piDisplayField {
  background-color: #e2eff6;
  margin-left: -10px;
  min-width: 250px;
  padding: 5px 20px 3px 25px;
  z-index: 100;
  -webkit-border-radius: 20px;
  -moz-border-radius: 3px;
  border-radius: 3px;
}
.app-settings .settings-form .settingsLabel {
  display: block;
  font-family: NotoSansBold, Helvetica, Arial;
  font-weight: normal;
  min-height: 20px;
  text-transform: uppercase;
  width: 100px;
}
table.settings-showLabels label {
  white-space: nowrap;
  width: auto;
}
table.settings-showLabels td {
  width: 130px;
}
.schedule-state-selector .x-boundlist-selected .x-form-checkbox {
  background-position: 0 -13px;
}
.statefieldvalue-boundlist-item img.stateFieldValue {
  background: transparent url('checkbox.gif');
  height: 13px;
  width: 13px;
}
.statefieldvalue-boundlist-selected img.stateFieldValue {
  background: transparent url('checkbox.gif');
  height: 13px;
  width: 13px;
  background-position-x: 0px;
  background-position-y: -13px;
}

    </style>

    <style type="text/css">
        .app {
  /* Add app styles here */
}
.fixTabMargins {
  margin: 0;
  padding: 0;
  height: 200px;
}
.x-tab-bar {
  background-color: white;
  border: none;
}
.x-panel-default {
  border: none;
}
.x-panel-body-default {
  border: none;
}
.x-tab-bar .x-tab-default .x-tab-inner {
  color: black;
}
.x-tab-bar .x-tab-active .x-tab-inner {
  color: black;
  text-decoration: underline;
}
h2 {
  margin: 0px;
  color: black;
  font-size: 18px;
  font-weight: bold;
  font-family: Gill Sans Extrabold, sans-serif;
}
h3 {
  margin: 0px;
  color: #666;
  font-size: 16px;
  font-weight: normal;
  font-family: Gill Sans Extrabold, sans-serif;
}
p {
  margin: 0px;
  color: #555;
  font-size: 20px;
  font-weight: normal;
  font-family: Gill Sans Extrabold, sans-serif;
}
li {
  list-style-type: disc;
}
ul,
ol {
  margin: 0;
  padding: 0;
}
/* Divs */
/* About */
.divTable {
  margin: 5px 0px 10px 0px;
  display: table;
  width: 100%;
}
.divTableBody {
  width: 100%;
}
.divTableRowHeader {
  display: table-row;
}
.divTableRowContent {
  display: table-row;
}
.divSpacer {
  width: 20px;
}
.headerBg2 {
  background: #eee;
}
.headerBg1 {
  background: white;
}
.contentBg2 {
  background: #eee;
}
.contentBg1 {
  background: white;
}
/* Buttons */
.print_button_over {
  background-color: white;
}
.black_button_text_color .x-btn-inner {
  color: black !important;
  font-weight: bold;
}

    </style>
</head>
<body>
</body>
</html>
